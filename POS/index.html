<!DOCTYPE html>
<html lang="zh-HK">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ç…å­å±± Lion Rock POS</title>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<!-- Supabase: load client & expose `supabaseClient` for the POS script -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script>
      // NOTE: This anon key is safe to use in the browser. Do not put your service role key here.
      const supabaseUrl = 'https://thmsnrncktwoajgclywa.supabase.co';
      const supabaseKey = 'sb_publishable_M1wpHSIK_pE55Y7-MBgSmQ_CRs0oj2C';
      const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);
    </script>
</head>
<body>
  <!-- Top tabs -->
  <div class="tabs">
    <button class="tab active" data-tab="pos-view">è½å–®</button>
    <button class="tab" data-tab="kitchen-view">å»šæˆ¿</button>
    <button class="tab" data-tab="bar-view">æ°´å§</button>
    <button class="tab" data-tab="all-orders-view">å…¨éƒ¨è¨‚å–®</button>
    <button class="tab" data-tab="customer-view">Customer View</button>
    <button class="tab" data-tab="waitlist-view">ç­‰ä½</button>
    <button class="tab" data-tab="admin-view">Admin</button>
  </div>

  <!-- POS view -->
  <div id="pos-view">
    <div class="main">
      <div class="left" id="menu-content"></div>

      <div class="right">
        <!-- Order meta (order #, service, channel) -->
        <div class="order-meta">
         <!-- Table number (we keep the same id so JS still works) -->
        <div class="order-meta-row">
         <label for="order-number">Table #</label>
         <input id="order-number" type="text" />
     </div>

     <!-- Combined order type: dine-in / tel / f2f / Deliveroo / JustEat -->
     <div class="order-meta-row">
        <label for="order-type">Type</label>
        <select id="order-type">
         <option value="dine-in">å ‚é£Ÿ</option>
        <option value="onsite">ç¾å ´å¤–è³£</option>
        <option value="tel">é›»è©±å¤–è³£</option>
        <option value="deliveroo">Deliveroo</option>
        <option value="justeat">Just Eat</option>
      </select>
    </div>

    <!-- Expected pickup time -->
    <div class="order-meta-row">
      <label for="pickup-time">Pickup</label>
      <input id="pickup-time" type="time" step="60" />
    </div>
  </div>

        <!-- Order summary -->
        <h2 style="font-size:1.8em;color:var(--green);margin-bottom:18px;">Order Summary</h2>
        <div id="order-list">
          <p class="empty-order">No items yet</p>
        </div>

        <!-- Discounts + total + Pay -->
        <div id="discount-summary" style="text-align:right; color:#d32f2f; font-weight:bold;"></div>
        <div class="total">
          <span>Total <span id="total">Â£0.00</span></span>
        </div>

        <!-- Card, Cash, Add, Unpaid pay buttons -->
       <div class="order-footer">
        <div class="pay-buttons">
         <button class="pay-btn" id="card-btn" type="button">Card</button>
         <button class="pay-btn pay-cash" id="pay-btn" type="button">Cash</button>
         <button class="pay-btn" id="platform-btn" type="button">Add</button>
         <button class="pay-btn" id="unpaid-btn" type="button">Unpaid</button>
       </div>
      </div>
    </div>
  </div>
 </div>

  <!-- Kitchen view (for food items) -->
  <div id="kitchen-view" style="display:none;">
    <div id="kitchen-orders" class="ticket-grid"></div>
  </div>

  <!-- Bar view (for drinks) -->
  <div id="bar-view" style="display:none;">
    <div id="bar-orders" class="ticket-grid"></div>
  </div>

  <!-- All orders view (combined food + drinks) -->
  <div id="all-orders-view" style="display:none;">
    <div style="display:flex;justify-content:flex-end;align-items:center;padding:8px 16px;background:#f0f2f5;">
  </div>

  <div id="all-orders" class="ticket-grid"></div>
</div>

<!-- Customer view -->
<div id="customer-view" style="display:none;">
  <div id="customer-screen" class="customer-screen"></div>
</div>

<!-- Waitlist view -->
<!-- Waitlist view -->
<div id="waitlist-view" style="display:none;">
  <div class="wl-page">

    <div class="wl-hero">
      <div class="wl-hero-title">ç™»è¨˜å€™ä½è¡¨ <span>Restaurant Waitlist</span></div>
    </div>

    <div class="wl-body">

      <!-- Form row -->
      <div class="wl-form">
        <div class="wl-field">
          <label>å§“å <span>Customer Name</span></label>
          <input id="wait-name" type="text" placeholder="è¼¸å…¥ Enter customer name" />
        </div>

        <div class="wl-field">
          <label>äººæ•¸ <span>Party Size</span></label>
          <select id="wait-pax">
            <option value="">é¸æ“‡ Select size</option>
            <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option>
            <option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="8">8</option>
          </select>
        </div>

        <button id="add-wait-btn" class="wl-confirm-btn" type="button">ç¢ºèª Confirm</button>
      </div>

      <!-- Big counter card -->
      <div class="wl-count-card">
        <div class="wl-count-number" id="wl-count">0</div>
        <div class="wl-count-label">ç­‰å¾…äººæ•¸ <span>Parties Waiting</span></div>
      </div>

      <!-- Table -->
      <div class="wl-table-wrap">
        <table class="wl-table">
         <colgroup>
           <col style="width:20%">
           <col style="width:20%">
           <col style="width:20%">
           <col style="width:20%">
           <col style="width:20%">
         </colgroup>
          <thead>
            <tr>
              <th>è™Ÿç¢¼ POSITION</th>
              <th>å§“å CUSTOMER NAME</th>
              <th>äººæ•¸ PARTY SIZE</th>
              <th>ç­‰å¾…æ™‚é–“ WAIT TIME</th>
              <th>ACTIONS</th>
            </tr>
          </thead>
          <tbody id="waitlist-tbody">
            <!-- rows injected by JS -->
          </tbody>
        </table>

        <!-- Empty state -->
        <div id="wl-empty" class="wl-empty" style="display:none;">
          <div class="wl-empty-title">No customers waiting</div>
        </div>
      </div>

    </div>
  </div>
</div>

<!-- Admin view -->
<div id="admin-view" style="display:none;">
  <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;padding:12px 16px;background:#f0f2f5;border-bottom:1px solid #ddd;">
    <div style="display:flex;gap:10px;align-items:center;">
      <strong>Daily Sales</strong>
      <input type="date" id="admin-date" />
      <button type="button" id="admin-refresh" class="export-btn">Refresh</button>
    </div>
    <button id="export-csv-btn" type="button" class="export-btn">Export CSV</button>
  </div>

  <div id="admin-summary" style="padding:16px;"></div>
</div>

  <!-- Options modal -->
  <div id="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
    <div class="modal-box">
      <div class="modal-head" id="modal-title">é¸æ“‡é¸é …</div>
      <div class="modal-body">
        <!-- (all your opts groups â€“ unchanged) -->
        <!-- ç†± / å‡ -->
        <div class="opts" id="hot-cold-opts" style="display:none;">
          <div class="opt">ç†±</div>
          <div class="opt">å‡</div>
        </div>

        <!-- ç²’ç²’æ¤°æ±ç´…è±†å†° -->
        <div class="opts" id="redbean-opts" style="display:none;">
          <div class="opt">å°‘å†°</div><div class="opt">èµ°å†°</div>
          <div class="opt">å°‘æ¤°å¥¶</div><div class="opt">å°‘èŠ±å¥¶</div>
          <div class="opt">èµ°æ¤°å¥¶</div><div class="opt">èµ°èŠ±å¥¶</div>
        </div>

        <!-- å¥½ç«‹å…‹ & é˜¿è¯ç”° -->
        <div class="opts" id="ovaltine-horlicks-opts" style="display:none;">
          <div class="opt">å°‘å†°</div><div class="opt">èµ°å†°</div><div class="opt">ç…‰å¥¶</div><div class="opt">å°‘ç”œ</div>
        </div>

        <!-- æŸšå­è–‘èœœ -->
        <div class="opts" id="citron-opts" style="display:none;">
          <div class="opt">å°‘å†°</div><div class="opt">èµ°å†°</div>
        </div>

        <!-- å¥¶èŒ¶å°ˆç”¨ -->
        <div class="opts" id="milktea-opts" style="display:none;">
          <div class="opt">å°‘å†°</div><div class="opt">èµ°å†°</div><div class="opt">å†°åº•</div>
          <div class="opt">ç…‰å¥¶</div><div class="opt">å°‘ç”œ</div>
        </div>

        <!-- å’–å•¡å°ˆç”¨ -->
        <div class="opts" id="coffee-opts" style="display:none;">
          <div class="opt">å°‘å†°</div><div class="opt">èµ°å†°</div>
          <div class="opt">èŠ±å¥¶</div><div class="opt">å°‘èŠ±å¥¶</div><div class="opt">ç…‰å¥¶</div><div class="opt">å°‘ç”œ</div>
        </div>

        <!-- é´›é´¦å°ˆç”¨ -->
        <div class="opts" id="yuenyeung-opts" style="display:none;">
          <div class="opt">å°‘å†°</div><div class="opt">èµ°å†°</div>
          <div class="opt">å°‘èŠ±å¥¶</div><div class="opt">ç…‰å¥¶</div><div class="opt">å°‘ç”œ</div>
        </div>

        <!-- è¥¿å¤šå£«å°ˆç”¨ -->
        <div class="opts" id="french-toast-opts" style="display:none;">
          <div class="opt">ç…‰å¥¶</div>
        </div>

        <!-- ä¸»é£Ÿé¸é … -->
        <div class="opts" id="brisket-opts" style="display:none;">
          <div class="opt">å¤šé£¯</div><div class="opt">å°‘é£¯</div><div class="opt">æ’ˆç²—</div><div class="opt">æ’ˆæ‹‰éºµ</div><div class="opt">æ’ˆä¸</div><div class="opt">æ¹¯ç²—</div><div class="opt">æ¹¯æ‹‰éºµ</div><div class="opt">æ¹¯ä¸</div>
          <div class="opt">æ·¨ç‰›è…©</div><div class="opt">æ·¨ç‰›ç­‹</div><div class="opt">å¤šç‰›è…©</div><div class="opt">å¤šç‰›ç­‹</div><div class="opt">å°‘ç‰›è…©</div><div class="opt">å°‘ç‰›ç­‹</div><div class="opt">èµ°ä¹¾è’œ</div>
        </div>
        <div class="opts" id="tomato-baked-opts" style="display:none;">
          <div class="opt">å¤šé£¯</div><div class="opt">å°‘é£¯</div><div class="opt">æ„ç²‰</div><div class="opt">å¤šè è˜¿</div>
          <div class="opt">èµ°è è˜¿</div><div class="opt">èµ°èŠå£«</div><div class="opt">è½‰é›æ‰’</div><div class="opt">å…ç„—</div>
        </div>
        <div class="opts" id="portuguese-opts" style="display:none;">
          <div class="opt">å¤šé£¯</div><div class="opt">å°‘é£¯</div><div class="opt">æ„ç²‰</div>
          <div class="opt">èµ°èŠå£«</div><div class="opt">è½‰è±¬æ‰’</div><div class="opt">å…ç„—</div>
        </div>
        <div class="opts" id="charsiu-opts" style="display:none;">
          <div class="opt">å¤šé£¯</div><div class="opt">å°‘é£¯</div><div class="opt">ç…ç†Ÿè›‹</div><div class="opt">æ’ˆç²—</div><div class="opt">èµ°ä¹¾è’œ</div>
        </div>
        <div class="opts" id="basic-rice-opts" style="display:none;">
          <div class="opt">å¤šé£¯</div><div class="opt">å°‘é£¯</div>
        </div>
        <div class="opts" id="plain-curry-opts" style="display:none;">
          <div class="opt">å¤šé£¯</div><div class="opt">å°‘é£¯</div><div class="opt">å¤šè–¯ä»”</div><div class="opt">å°‘è–¯ä»”</div>
          <div class="opt">èµ°è–¯ä»”</div><div class="opt">èµ°ä¹¾è’œ</div>
        </div>
        <div class="opts" id="baked-curry-opts" style="display:none;">
          <div class="opt">å¤šé£¯</div><div class="opt">å°‘é£¯</div><div class="opt">æ„ç²‰</div><div class="opt">å¤šè–¯ä»”</div>
          <div class="opt">å°‘è–¯ä»”</div><div class="opt">èµ°è–¯ä»”</div><div class="opt">èµ°èŠå£«</div><div class="opt">å…ç„—</div>
        </div>
        <div class="opts" id="spring-onion-opts" style="display:none;">
          <div class="opt">å¤šé£¯</div><div class="opt">å°‘é£¯</div><div class="opt">æ’ˆä¸</div><div class="opt">æ’ˆç²—</div>
          <div class="opt">æ’ˆæ‹‰éºµ</div><div class="opt">æ¹¯ç±³</div><div class="opt">æ¹¯é€š</div><div class="opt">æ¹¯æ„</div>
          <div class="opt">å¤šè”¥æ²¹</div><div class="opt">å°‘è”¥æ²¹</div><div class="opt">ç…ç†Ÿè›‹</div><div class="opt">èµ°ä¹¾è’œ</div>
        </div>
        <div class="opts" id="chakee-noodles-opts" style="display:none;">
          <div class="opt">ä¸</div><div class="opt">æ¹¯ç±³</div><div class="opt">æ¹¯é€š</div><div class="opt">æ¹¯æ„</div>
          <div class="opt">æ¹¯ç²—</div><div class="opt">æ¹¯æ‹‰éºµ</div>
          <div class="opt">å¤ªé™½è›‹</div><div class="opt">ç…ç†Ÿè›‹</div><div class="opt">ç‚’ç†Ÿè›‹</div>
          <div class="opt">èµ°åŒ…</div><div class="opt">åŒ…èµ°ç‰›æ²¹</div><div class="opt">åŒ…å°‘ç‰›æ²¹</div><div class="opt">åŒ…å¤šç‰›æ²¹</div><div class="opt">åŒ…å””çƒ˜</div><div class="opt">åŒ…çƒ˜è€å•²</div>
        </div>

        <!-- èŒ¶è¨˜ç²‰é¢ - é¤ -->
        <div class="opts" id="set-meal-opts" style="display:none;">
          <div class="opt">é¤</div>
        </div>

        <!-- Global options (all items) -->
         <div class="opts" id="global-opts" style="display:none;">
         <div class="opt">å¤–è³£</div>
         <div class="opt">å¾Œä¸Š</div>
        </div>

        <textarea placeholder="ç‰¹åˆ¥è¦æ±‚..."></textarea>
      </div>
      <div class="modal-footer">
        <button class="cancel" id="cancel">Cancel</button>
        <button class="confirm" id="add">Add to Order</button>
      </div>
    </div>
  </div>

  <!-- Payment modal -->
  <div id="pay-modal">
    <div class="pay-box">
      <div class="pay-head">Payment</div>
      <div class="pay-body">
        <div class="pay-row">
          <span>Amount due:</span>
          <strong id="amount-due">Â£0.00</strong>
        </div>

        <div class="pay-row">
          <label for="amount-received">Cash received:</label>
          <input type="number" id="amount-received" step="0.01" min="0" />
        </div>
        <!-- QUICK CASH PRESETS (ADD THIS) -->
        <div class="cash-presets">
         <button type="button" class="preset-btn" data-val="exact">Exact</button>
         <button type="button" class="preset-btn" data-val="10">Â£10</button>
         <button type="button" class="preset-btn" data-val="20">Â£20</button>
         <button type="button" class="preset-btn" data-val="30">Â£30</button>
         <button type="button" class="preset-btn" data-val="50">Â£50</button>
        </div>

        <div class="pay-row pay-change">
          <span>Change:</span>
          <strong id="change-amount">Â£0.00</strong>
        </div>
      </div>
      <div class="pay-footer">
        <button type="button" id="pay-cancel" class="cancel">Cancel</button>
        <button type="button" id="pay-confirm" class="confirm">Confirm</button>
      </div>
    </div>
  </div>

<script>
const menu = [
  // ä¸»é£Ÿ & å’–å–±ç³»åˆ—
  { name:"å’–å–±é›æ‰’é£¯", price:11.8, cat:"å’–å–±ç³»åˆ—", optionGroups:["plain-curry-opts"], hotCold:false },
  { name:"å’–å–±è±¬æ‰’é£¯", price:11.8, cat:"å’–å–±ç³»åˆ—", optionGroups:["plain-curry-opts"], hotCold:false },
  { name:"å’–å–±ç‰›è…©é£¯", price:12.3, cat:"å’–å–±ç³»åˆ—", optionGroups:["plain-curry-opts"], hotCold:false },
  { name:"ç„—å’–å–±é›æ‰’é£¯", price:12.8, cat:"å’–å–±ç³»åˆ—", optionGroups:["baked-curry-opts"], hotCold:false },
  { name:"ç„—å’–å–±è±¬æ‰’é£¯", price:12.8, cat:"å’–å–±ç³»åˆ—", optionGroups:["baked-curry-opts"], hotCold:false },
  { name:"ç„—å’–å–±ç‰›è…©é£¯", price:13.3, cat:"å’–å–±ç³»åˆ—", optionGroups:["baked-curry-opts"], hotCold:false },

  { name:"æ²™å—²ç‰›è‚‰", price:8.9, cat:"èŒ¶è¨˜ç²‰é¢", optionGroups:["chakee-noodles-opts","set-meal-opts"], hotCold:false, DingName: "æ²™å—²ç‰›è‚‰ä¸", SoupVermicelliName:"æ²™å—²ç‰›è‚‰æ¹¯ç±³", SoupMacaroniName:"æ²™å—²ç‰›è‚‰æ¹¯é€š", SoupSpaghettiName:"æ²™å—²ç‰›è‚‰æ¹¯æ„", SoupMeinName:"æ²™å—²ç‰›è‚‰æ¹¯ç²—", SoupRamenName:"æ²™å—²ç‰›è‚‰æ¹¯æ‹‰éºµ"},
  { name:"é›ªèœè‚‰çµ²", price:8.4, cat:"èŒ¶è¨˜ç²‰é¢", optionGroups:["chakee-noodles-opts","set-meal-opts"], hotCold:false, DingName: "é›ªèœè‚‰çµ²ä¸", SoupVermicelliName:"é›ªèœè‚‰çµ²æ¹¯ç±³", SoupMacaroniName:"é›ªèœè‚‰çµ²æ¹¯é€š", SoupSpaghettiName:"é›ªèœè‚‰çµ²æ¹¯æ„", SoupMeinName:"é›ªèœè‚‰çµ²æ¹¯ç²—", SoupRamenName:"é›ªèœè‚‰çµ²æ¹¯æ‹‰éºµ" },
  { name:"å‰ç‡’", price:8.4, cat:"èŒ¶è¨˜ç²‰é¢", optionGroups:["chakee-noodles-opts","set-meal-opts"], hotCold:false, DingName: "å‰ç‡’ä¸", SoupVermicelliName:"å‰ç‡’æ¹¯ç±³", SoupMacaroniName:"å‰ç‡’æ¹¯é€š", SoupSpaghettiName:"å‰ç‡’æ¹¯æ„", SoupMeinName:"å‰ç‡’æ¹¯ç²—", SoupRamenName:"å‰ç‡’æ¹¯æ‹‰éºµ" },
  { name:"äº”é¦™è‚‰ä¸", price:8.4, cat:"èŒ¶è¨˜ç²‰é¢", optionGroups:["chakee-noodles-opts","set-meal-opts"], hotCold:false, DingName: "äº”é¦™è‚‰ä¸", SoupVermicelliName:"äº”é¦™è‚‰ä¸æ¹¯ç±³", SoupMacaroniName:"äº”é¦™è‚‰ä¸æ¹¯é€š", SoupSpaghettiName:"äº”é¦™è‚‰ä¸æ¹¯æ„", SoupMeinName:"äº”é¦™è‚‰ä¸æ¹¯ç²—", SoupRamenName:"äº”é¦™è‚‰ä¸æ¹¯æ‹‰éºµ" },
  { name:"ç«è…¿", price:7.9, cat:"èŒ¶è¨˜ç²‰é¢", optionGroups:["chakee-noodles-opts","set-meal-opts"], hotCold:false, DingName: "ç«è…¿ä¸", SoupVermicelliName:"ç«è…¿æ¹¯ç±³", SoupMacaroniName:"ç«è…¿æ¹¯é€š", SoupSpaghettiName:"ç«è…¿æ¹¯æ„", SoupMeinName:"ç«è…¿æ¹¯ç²—", SoupRamenName:"ç«è…¿æ¹¯æ‹‰éºµ" },

  { name:"æŸ±ä¾¯ç‰›è…©é£¯", price:11.8, cat:"ä¸»é£Ÿ", optionGroups:["brisket-opts"], hotCold:false, loMeinName:"æŸ±ä¾¯ç‰›ç­‹è…©æ’ˆç²—", loRamenName:"æŸ±ä¾¯ç‰›è…©æ’ˆæ‹‰éºµ", loDingName:"æŸ±ä¾¯ç‰›è…©æ’ˆä¸", SoupMeinName:"æŸ±ä¾¯ç‰›ç­‹è…©æ¹¯ç²—", SoupRamenName:"æŸ±ä¾¯ç‰›ç­‹è…©æ¹¯æ‹‰éºµ", SoupDingName:"æŸ±ä¾¯ç‰›ç­‹è…©æ¹¯ä¸"},
  { name:"èœœæ±å‰ç‡’ç…è›‹é£¯", price:11.5, cat:"ä¸»é£Ÿ", optionGroups:["charsiu-opts"], hotCold:false, loMeinName:"èœœæ±å‰ç‡’ç…è›‹æ’ˆç²—" },
  { name:"é®®èŒ„ç„—è±¬æ‰’é£¯", price:12.5, cat:"ä¸»é£Ÿ", optionGroups:["tomato-baked-opts"], hotCold:false },
  { name:"è‘¡æ±ç„—é›æ‰’é£¯", price:12.5, cat:"ä¸»é£Ÿ", optionGroups:["portuguese-opts"], hotCold:false },
  { name:"è”¥æ²¹é›æ‰’ç…è›‹é£¯", price:10.8, cat:"ä¸»é£Ÿ", optionGroups:["spring-onion-opts"], hotCold:false, loMeinName:"è”¥æ²¹é›æ‰’ç…è›‹æ’ˆç²—", loRamenName:"è”¥æ²¹é›æ‰’ç…è›‹æ’ˆæ‹‰éºµ", loDingName:"è”¥æ²¹é›æ‰’ç…è›‹æ’ˆä¸", SoupVermicelliName:"è”¥æ²¹é›æ‰’ç…è›‹æ¹¯ç±³", SoupMacaroniName:"è”¥æ²¹é›æ‰’ç…è›‹æ¹¯é€š", SoupSpaghettiName:"è”¥æ²¹é›æ‰’ç…è›‹æ¹¯æ„" },
  { name:"è”¥æ²¹è±¬æ‰’ç…è›‹é£¯", price:10.8, cat:"ä¸»é£Ÿ", optionGroups:["spring-onion-opts"], hotCold:false, loMeinName:"è”¥æ²¹è±¬æ‰’ç…è›‹æ’ˆç²—", loRamenName:"è”¥æ²¹è±¬æ‰’ç…è›‹æ’ˆæ‹‰éºµ", loDingName:"è”¥æ²¹è±¬æ‰’ç…è›‹æ’ˆä¸", SoupVermicelliName:"è”¥æ²¹è±¬æ‰’ç…è›‹æ¹¯ç±³", SoupMacaroniName:"è”¥æ²¹è±¬æ‰’ç…è›‹æ¹¯é€š", SoupSpaghettiName:"è”¥æ²¹è±¬æ‰’ç…è›‹æ¹¯æ„"  },
  { name:"æ³¡èœäº”èŠ±è…©é£¯", price:11.5, cat:"ä¸»é£Ÿ", optionGroups:["basic-rice-opts"], hotCold:false },
  { name:"æ»‘è›‹é°»é­šé£¯", price:13.5, cat:"ä¸»é£Ÿ", optionGroups:["basic-rice-opts"], hotCold:false },

  // é£²å“
  { name:"å¥¶èŒ¶", price:3.8, cat:"é£²å“", optionGroups:["hot-cold-opts","milktea-opts"], hotCold:true },
  { name:"ç²’ç²’æ¤°æ±ç´…è±†å†°", price:4.0, cat:"é£²å“", optionGroups:["redbean-opts"], hotCold:false },
  { name:"æª¸èŒ¶", price:3.0, cat:"é£²å“", optionGroups:["hot-cold-opts"], hotCold:true },
  { name:"æª¸æ°´", price:3.0, cat:"é£²å“", optionGroups:["hot-cold-opts"], hotCold:true },
  { name:"å‡å’¸æª¸ä¸ƒ", price:3.5, cat:"é£²å“", optionGroups:[], hotCold:false },
  { name:"å¥½ç«‹å…‹", price:3.0, cat:"é£²å“", optionGroups:["hot-cold-opts","ovaltine-horlicks-opts"], hotCold:true },
  { name:"é˜¿è¯ç”°", price:3.0, cat:"é£²å“", optionGroups:["hot-cold-opts","ovaltine-horlicks-opts"], hotCold:true },
  { name:"æŸšå­è–‘èœœ", price:3.0, cat:"é£²å“", optionGroups:["hot-cold-opts","citron-opts"], hotCold:true },
  { name:"å‡æª¸æ¨‚", price:2.5, cat:"é£²å“", optionGroups:[], hotCold:false },
  { name:"å’–å•¡", price:2.0, cat:"é£²å“", optionGroups:["hot-cold-opts","coffee-opts"], hotCold:true },
  { name:"Coke", price:2.0, cat:"é£²å“", optionGroups:[], hotCold:false },
  { name:"Zero", price:2.0, cat:"é£²å“", optionGroups:[], hotCold:false },
  { name:"7up", price:2.0, cat:"é£²å“", optionGroups:[], hotCold:false },
  { name:"é´›é´¦", price:3.8, cat:"é£²å“", optionGroups:["hot-cold-opts","yuenyeung-opts"], hotCold:true },

// å¥—é¤æ‰‹å‹•æŠ˜æ‰£
  { name:"å¥—é¤ -Â£0.5", price:-0.5, cat:"é£²å“", optionGroups:[], hotCold:false, isManualDiscount:true },

  // å°é£Ÿ
  { name:"åœŸåŒªé›ç¿¼", price:4.4, cat:"å°é£Ÿ", optionGroups:[], hotCold:false },
  { name:"é¹µæ°´ç‰›å±•", price:4.4, cat:"å°é£Ÿ", optionGroups:[], hotCold:false },
  { name:"èŠ±ç”Ÿé†¬è¥¿å¤šå£«", price:6.5, cat:"å°é£Ÿ", optionGroups:["french-toast-opts"], hotCold:false },
  { name:"åŠä»½è¥¿å¤šå£«", price:4.0, cat:"å°é£Ÿ", optionGroups:["french-toast-opts"], hotCold:false },
  { name:"ç‚’è›‹å¤šå£«", price:2.0, cat:"å°é£Ÿ", optionGroups:[], hotCold:false, excludeFromComboB:true },
];

let order = [];
let current = null;
let isCash = false;
let lastBaseTotal = 0;
let lastFinalTotal = 0;
let lastSubtotal = 0;
let lastComboACount = 0;
let lastComboBCount = 0;
let lastMealDealDiscount = 0;
let lastCashDiscount = 0;
let nextOrderId = 1;
let kitchenOrders = [];
let completedOrders = [];
let archivedOrders = [];   // orders that have been fully completed in kitchen/bar
let payingOrderId = null;   // when paying an existing Unpaid ticket
let adminUnlocked = false;
let waitlist = [];
let editingTicketItem = null;

// ----------------------
// Date helpers: "today" range in ISO for Supabase
// ----------------------
// We use the device's local timezone to define the restaurant day,
// then convert to ISO so Supabase can filter by created_at.
function getTodayRangeISO() {
  const now = new Date();

  // Local midnight today (00:00 on this device)
  const startLocal = new Date(
    now.getFullYear(),
    now.getMonth(),
    now.getDate(),
    0, 0, 0, 0
  );

  // Local midnight tomorrow
  const endLocal = new Date(startLocal.getTime() + 24 * 60 * 60 * 1000);

  // Convert to ISO (UTC) â€” Supabase stores timestamptz in UTC
  return {
    start: startLocal.toISOString(),
    end: endLocal.toISOString()
  };
}

// shape: { ticketId: string, lane: 'food'|'drink', index: number }
const ADMIN_PASSWORD = '1234'; // change this

// === Editing & Direct Add Controls ===
let editingOrderItemIndex = null;
let pendingItemToAdd = null;

// ===== Device access mode (cashier vs customer tablet) =====
function getMode() {
  const params = new URLSearchParams(window.location.search);
  return (params.get('mode') || '').toLowerCase();
}

function applyTabAccessMode() {
  const mode = getMode();
  if (mode !== 'customer') return;

  // Only allow these TWO views on a customer tablet
  const allowedViews = new Set(['customer-view', 'waitlist-view']);

  // Hide tab buttons that are not allowed
  document.querySelectorAll('.tab[data-tab]').forEach(btn => {
    const viewId = btn.dataset.tab; // e.g. "customer-view"
    if (!allowedViews.has(viewId)) {
      btn.style.display = 'none';
    }
  });

  // Hide view containers that are not allowed
  const allViews = [
    'pos-view',
    'kitchen-view',
    'bar-view',
    'all-orders-view',
    'customer-view',
    'waitlist-view',
    'admin-view'
  ];

  allViews.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;

    el.style.display = allowedViews.has(id) ? 'block' : 'none';
    if (id === 'pos-view' && allowedViews.has(id)) el.style.display = 'flex';
  });

  // Force switch to Customer View tab
  switchToView('customer-view');
}

const DIRECT_ADD_CATEGORIES = ["å’–å–±ç³»åˆ—", "ä¸»é£Ÿ", "å°é£Ÿ"];
const DIRECT_ADD_DRINKS = [
  "Coke",
  "Zero",
  "7up",
  "å‡æª¸æ¨‚",
  "å‡å’¸æª¸ä¸ƒ",
  "æŸšå­è–‘èœœ",
  "ç²’ç²’æ¤°æ±ç´…è±†å†°",
  "å¥—é¤ -Â£0.5",
];

function renderMenu() {
  const catOrder = ["å’–å–±ç³»åˆ—","èŒ¶è¨˜ç²‰é¢","ä¸»é£Ÿ","é£²å“","å°é£Ÿ"];
  const menuContent = document.getElementById('menu-content');

  const itemsWithIndex = menu.map((item, index) => ({ ...item, index }));
  const html = catOrder.map(cat => {
    const items = itemsWithIndex.filter(i => i.cat === cat);
    if (!items.length) return '';
    const itemsHtml = items.map(item => `
      <button type="button" class="item" data-index="${item.index}">
        <h3>${item.name}</h3>
        <div class="price">Â£${item.price.toFixed(2)}</div>
      </button>
    `).join('');
    return `
      <div class="category">
        <h2>${cat}</h2>
        <div class="grid">
          ${itemsHtml}
        </div>
      </div>
    `;
  }).join('');

  menuContent.innerHTML = html;
}

function openModal(item, menuIndex) {
  current = {
    baseName: item.name,
    price: item.price,
    isHotCold: !!item.hotCold,
    loMeinName: item.loMeinName || null,
    loRamenName: item.loRamenName || null,
    loDingName: item.loDingName || null,
    SoupMeinName: item.SoupMeinName || null,
    SoupRamenName: item.SoupRamenName || null,
    SoupDingName: item.SoupDingName || null,
    SoupVermicelliName: item.SoupVermicelliName || null,
    SoupMacaroniName: item.SoupMacaroniName || null,
    SoupSpaghettiName: item.SoupSpaghettiName || null,
    DingName: item.DingName || null,
    cat: item.cat,
    menuIndex: (typeof menuIndex === 'number') ? menuIndex : null,
    excludeFromComboB: !!item.excludeFromComboB
  };

  const head = document.querySelector('.modal-head');
  if (head) head.textContent = `é¸æ“‡é¸é …ï¼š${item.name}`;

  document.querySelectorAll('.opts').forEach(o => o.style.display = 'none');

  // Always show the universal options for every item
  const globalOpts = document.getElementById('global-opts');
  if (globalOpts) globalOpts.style.display = 'grid';

  if (Array.isArray(item.optionGroups)) {
    item.optionGroups.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = 'grid';
    });
  }

  document.querySelectorAll('.opt').forEach(o => o.classList.remove('sel'));
  const noteEl = document.querySelector('#modal textarea');
  if (noteEl) noteEl.value = '';

  if (editingOrderItemIndex !== null && order[editingOrderItemIndex]) {
    const existing = order[editingOrderItemIndex];
    const existingMods = Array.isArray(existing.mods) ? existing.mods : [];

    const visibleOpts = Array.from(document.querySelectorAll('.opts'))
      .filter(group => group.style.display !== 'none')
      .flatMap(group => Array.from(group.querySelectorAll('.opt')));

    const usedMods = new Set();

    visibleOpts.forEach(opt => {
      const label = opt.textContent.trim();
      if (existingMods.includes(label)) {
        opt.classList.add('sel');
        usedMods.add(label);
      }
    });

    const leftover = existingMods.filter(m => !usedMods.has(m));
    if (leftover.length && noteEl) {
      noteEl.value = leftover.join(', ');
    }
  }

  document.getElementById('modal').style.display = 'flex';
}

function escapeHtml(str) {
  str = String(str ?? '');
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

function updateOrder() {
  const list = document.getElementById('order-list');
  const discountBox = document.getElementById('discount-summary');
  let subtotal = 0;

  let mainCount = 0;
  let drinkCount = 0;
  let snackCount = 0;

  if (!order.length) {
    list.innerHTML = '<p class="empty-order">No items yet</p>';
    if (discountBox) discountBox.textContent = '';
  } else {
    let html = '';
    order.forEach((o, i) => {
      subtotal += o.final; 
      let name = o.displayName;

    if (!o.isManualDiscount) {
      if (o.cat === 'å’–å–±ç³»åˆ—' || o.cat === 'èŒ¶è¨˜ç²‰é¢' || o.cat === 'ä¸»é£Ÿ') {
        mainCount++;
      } else if (o.cat === 'é£²å“') {
        drinkCount++;
      } else if (o.cat === 'å°é£Ÿ' && !o.excludeFromComboB) {
        snackCount++;
      }
    }

      if (o.isSpaghetti) name = name.replace(/æ„ç²‰/g,'<span class="red">æ„ç²‰</span>');
      if (o.swapToChicken) name = name.replace('è±¬æ‰’','<span class="red">é›æ‰’</span>');
      if (o.swapToPork) name = name.replace('é›æ‰’','<span class="red">è±¬æ‰’</span>');
      if (o.isLoMein) name = name.replace('æ’ˆç²—','<span class="red">æ’ˆç²—</span>');
      if (o.isLoRamen) name = name.replace('æ’ˆæ‹‰éºµ','<span class="red">æ’ˆæ‹‰éºµ</span>');
      if (o.isLoDing) name = name.replace('æ’ˆä¸','<span class="red">æ’ˆä¸</span>');
      if (o.isSoupMein) name = name.replace('æ¹¯ç²—','<span class="red">æ¹¯ç²—</span>');
      if (o.isSoupRamen) name = name.replace('æ¹¯æ‹‰éºµ','<span class="red">æ¹¯æ‹‰éºµ</span>');
      if (o.isSoupDing) name = name.replace('æ¹¯ä¸','<span class="red">æ¹¯ä¸</span>');
      if (o.isSoupVermicelli) name = name.replace('æ¹¯ç±³','<span class="red">æ¹¯ç±³</span>');
      if (o.isSoupMacaroni) name = name.replace('æ¹¯é€š','<span class="red">æ¹¯é€š</span>');
      if (o.isSoupSpaghetti) name = name.replace('æ¹¯æ„','<span class="red">æ¹¯æ„</span>');
      if (o.isDing) name = name.replace('ä¸','<span class="red">ä¸</span>');
      if (o.isSetMeal) {name += ' <span class="blue">é¤</span>';}



      const modsHtml = o.mods.length
        ? `<small style="color:#666;">${o.mods.map(escapeHtml).join(', ')}</small>`
        : '';

      html += `
        <div class="order-item">
          <div class="info">
            <div class="price-line">Â£${o.final.toFixed(2)}</div>
            <div>${name}</div>
            ${modsHtml}
          </div>
          <div class="order-actions">
            <button class="edit-btn" data-index="${i}" aria-label="Edit item">
              <i class="fas fa-pen"></i>
            </button>
            <button class="delete-btn" data-index="${i}" aria-label="Remove item">
              <i class="fas fa-trash-alt"></i>
            </button>
          </div>
        </div>
      `;
    });
    list.innerHTML = html;
  }

  let comboBCount = Math.min(mainCount, drinkCount, snackCount);
  mainCount -= comboBCount;
  drinkCount -= comboBCount;
  let comboACount = Math.min(mainCount, drinkCount);

  const mealDealDiscount = comboBCount * 1.0 + comboACount * 0.5;
  const baseTotal = subtotal - mealDealDiscount;

  let cashDiscount = 0;
  let finalTotal = baseTotal;

  if (isCash && baseTotal > 0) {
    cashDiscount = baseTotal * 0.05;
    finalTotal = baseTotal - cashDiscount;
    finalTotal = Math.floor(finalTotal * 10) / 10;
  }

  lastBaseTotal = baseTotal;
  lastFinalTotal = (isCash && finalTotal > 0) ? finalTotal : baseTotal;
  lastSubtotal = subtotal;
  lastComboACount = comboACount;
  lastComboBCount = comboBCount;
  lastMealDealDiscount = mealDealDiscount;
  lastCashDiscount = cashDiscount;

  if (discountBox) {
    if (!order.length || (mealDealDiscount <= 0 && (!isCash || cashDiscount <= 0))) {
      discountBox.textContent = '';
    } else {
      let lines = [];
      if (comboACount > 0) {
        lines.push(`Combo A x${comboACount}: -Â£${(comboACount * 0.5).toFixed(2)}`);
      }
      if (comboBCount > 0) {
        lines.push(`Combo B x${comboBCount}: -Â£${(comboBCount * 1.0).toFixed(2)}`);
      }
      if (isCash && cashDiscount > 0) {
        lines.push(`Cash 5%: -Â£${cashDiscount.toFixed(2)}`);
      }
      discountBox.innerHTML = lines.join('<br>');
    }
  }

  const totalEl = document.getElementById('total');
  if (isCash && finalTotal > 0) {
    totalEl.textContent = 'Â£' + finalTotal.toFixed(1);
  } else {
    totalEl.textContent = 'Â£' + baseTotal.toFixed(2);
  }

  // âœ… keep Customer screen in sync
  renderCustomerView();
}

document.getElementById('add').addEventListener('click', () => {
  if (!current) {
    alert('No item is selected â€“ please close this window and click a menu item again.');
    return;
  }

    const sel = Array.from(
    document.querySelectorAll('#modal .opts')
  )
    .filter(group => group.style.display !== 'none')
    .flatMap(group => Array.from(group.querySelectorAll('.opt.sel')));

  const mods = sel.map(o => o.textContent.trim());
  const noteEl = document.querySelector('#modal textarea');
  const note = noteEl ? noteEl.value.trim() : '';
  if (note) mods.push(note);

  let name = current.baseName;
  let price = current.price;
  let isSpaghetti = false;
  let isLoMein = false;
  let isLoRamen = false;
  let isLoDing = false;
  let isSoupMein = false;
  let isSoupRamen = false;
  let isSoupDing = false;
  let isSoupVermicelli = false;
  let isSoupMacaroni = false;
  let isSoupSpaghetti = false;
  let isDing = false;
  let swapToChicken = false;
  let swapToPork = false;
  let isSetMeal = false;
  let addedSpringOnionLoCharge = false;

  sel.forEach(opt => {
    const v = opt.textContent.trim();
    if (v === 'æ„ç²‰') {
      name = name.replace('é£¯','æ„ç²‰');
      isSpaghetti = true;
    }
    if (v === 'è½‰é›æ‰’') {
      name = name.replace('è±¬æ‰’','é›æ‰’');
      swapToChicken = true;
    }
    if (v === 'è½‰è±¬æ‰’') {
      name = name.replace('é›æ‰’','è±¬æ‰’');
      swapToPork = true;
    }
    if (v === 'æ’ˆç²—' && current.loMeinName) {
      name = current.loMeinName;
      isLoMein = true;
    }
    if (v === 'æ’ˆæ‹‰éºµ' && current.loRamenName) {
      name = current.loRamenName;
      isLoRamen = true;
    }
    if (v === 'æ’ˆä¸' && current.loDingName) {
      name = current.loDingName;
      isLoDing = true;
    }
    if (
      !addedSpringOnionLoCharge &&
      (v === 'æ’ˆç²—' || v === 'æ’ˆä¸') &&
      (current.baseName === 'è”¥æ²¹é›æ‰’ç…è›‹é£¯' ||
       current.baseName === 'è”¥æ²¹è±¬æ‰’ç…è›‹é£¯')
    ) {
      price += 1;
      addedSpringOnionLoCharge = true;
    }
    if (v === 'æ¹¯ç²—' && current.SoupMeinName) {
      name = current.SoupMeinName;
      isSoupMein = true;
    }
    if (v === 'æ¹¯æ‹‰éºµ' && current.SoupRamenName) {
      name = current.SoupRamenName;
      isSoupRamen = true;
    }
    if (v === 'æ¹¯ä¸' && current.SoupDingName) {
      name = current.SoupDingName;
      isSoupDing = true;
    }
    if (v === 'æ¹¯ç±³' && current.SoupVermicelliName) {
      name = current.SoupVermicelliName;
      isSoupVermicelli = true;
    }
    if (v === 'æ¹¯é€š' && current.SoupMacaroniName) {
      name = current.SoupMacaroniName;
      isSoupMacaroni = true;
    }
    if (v === 'æ¹¯æ„' && current.SoupSpaghettiName) {
      name = current.SoupSpaghettiName;
      isSoupSpaghetti = true;
    }
    if (v === 'ä¸' && current.DingName) {
      name = current.DingName;
      isDing = true;
    }
    if ((v === 'ç†±' || v === 'å‡') && current.isHotCold) {
      name = v + name;
    }
    if (v === 'é¤') {
      price += 2;
      isSetMeal = true;
    }
  });

  const newItem = {
    displayName: name,
    final: price,
    mods,
    isSpaghetti,
    isLoMein,
    isLoRamen,
    isLoDing,
    isSoupMein,
    isSoupRamen,
    isSoupDing,
    isSoupVermicelli,
    isSoupMacaroni,
    isSoupSpaghetti,
    isDing,
    isSetMeal,
    swapToChicken,
    swapToPork,
    cat: current.cat,
    menuIndex: (typeof current.menuIndex === 'number') ? current.menuIndex : null,
    excludeFromComboB: !!current.excludeFromComboB
  };

  // âœ… If editing an All Orders ticket item, save back into that ticket instead of POS order[]
  if (editingTicketItem) {
    const ticket = findTicketById(editingTicketItem.ticketId);
    if (ticket) {
      const arr = (editingTicketItem.lane === 'food') ? ticket.foodItems : ticket.drinkItems;
      const old = arr && arr[editingTicketItem.index];

      if (arr && old) {
        // preserve status (complete/in-progress) and anything else not in newItem
        arr[editingTicketItem.index] = {
          ...old,
          ...newItem,
          status: old.status || 'in-progress'
        };
      }

      // âœ… also update completedOrders record (for CSV/admin) if it exists
      const summary = completedOrders.find(o => o.id === ticket.id);
      if (summary) {
        summary.items = [
          ...(ticket.foodItems || []),
          ...(ticket.drinkItems || [])
        ].map(it => ({
          name: it.displayName || it.name || '',
          category: it.cat || '',
          amount: Number(it.final ?? it.price ?? 0) || 0
        }));
      }
    }

    // cleanup + refresh views
    editingTicketItem = null;
    editingOrderItemIndex = null;

    document.getElementById('modal').style.display = 'none';
    current = null;

    renderKitchenView();
    renderBarView();
    renderAllOrdersView();
    if (adminUnlocked) renderAdminView();

    return;
  }

  if (editingOrderItemIndex !== null && typeof editingOrderItemIndex === 'number') {
    order[editingOrderItemIndex] = newItem;
  } else {
    order.push(newItem);
  }

  editingOrderItemIndex = null;
  updateOrder();
  document.getElementById('modal').style.display = 'none';
  current = null;
});

document.getElementById('cancel').addEventListener('click', () => {
  document.getElementById('modal').style.display = 'none';
  current = null;
  editingOrderItemIndex = null;
  editingTicketItem = null;
});

// Menu click delegation with direct-add logic
document.getElementById('menu-content').addEventListener('click', e => {
  const card = e.target.closest('.item');
  if (!card) return;

  const index = parseInt(card.dataset.index, 10);
  if (Number.isNaN(index)) return;

  const item = menu[index];

  const isDirectCategory = DIRECT_ADD_CATEGORIES.includes(item.cat);
  const isDirectDrink = DIRECT_ADD_DRINKS.includes(item.name);

  if (isDirectCategory || isDirectDrink) {
    order.push({
      displayName: item.name,
      final: item.price,
      mods: [],
      cat: item.cat,
      menuIndex: index,
      isManualDiscount: item.isManualDiscount || false,
      excludeFromComboB: !!item.excludeFromComboB
    });
    updateOrder();
  } else {
    editingOrderItemIndex = null;
    openModal(item, index);
  }
});

// Order delete delegation
document.getElementById('order-list').addEventListener('click', e => {
  const btn = e.target.closest('.delete-btn');
  if (!btn) return;

  const idx = parseInt(btn.dataset.index, 10);
  if (Number.isNaN(idx)) return;

  order.splice(idx, 1);
  updateOrder();
});

// Order edit delegation
document.getElementById('order-list').addEventListener('click', e => {
  const btn = e.target.closest('.edit-btn');
  if (!btn) return;

  const idx = parseInt(btn.dataset.index, 10);
  if (Number.isNaN(idx)) return;

  const item = order[idx];
  if (!item) return;

  editingOrderItemIndex = idx;

  let menuIndex = (typeof item.menuIndex === 'number') ? item.menuIndex : -1;

  if (menuIndex < 0) {
    const baseName = item.displayName.replace(/^(ç†±|å‡)/, '');
    menuIndex = menu.findIndex(m => m.name === baseName);
  }

  if (menuIndex < 0) {
    alert('Cannot edit this item (no matching menu entry found).');
    editingOrderItemIndex = null;
    return;
  }

  const menuItem = menu[menuIndex];
  openModal(menuItem, menuIndex);
});

// Options click behaviour
document.querySelectorAll('.opt').forEach(o => {
  o.addEventListener('click', () => {
    const parent = o.parentElement;
    if (parent && parent.id === 'hot-cold-opts') {
      parent.querySelectorAll('.opt').forEach(sib => sib.classList.remove('sel'));
      o.classList.add('sel');
    } else {
      o.classList.toggle('sel');
    }
  });
});

const payBtn = document.getElementById('pay-btn');
const payModal = document.getElementById('pay-modal');
const amountDueEl = document.getElementById('amount-due');
const amountInput = document.getElementById('amount-received');
const changeEl = document.getElementById('change-amount');
const payCancel = document.getElementById('pay-cancel');
const payConfirm = document.getElementById('pay-confirm');
const cardBtn = document.getElementById('card-btn');

const platformBtn = document.getElementById('platform-btn');
const orderTypeSelect = document.getElementById('order-type');

function isPlatformOrder() {
  const v = orderTypeSelect ? orderTypeSelect.value : '';
  return v === 'deliveroo' || v === 'justeat';
}

function syncPayButtonsByType() {
  const cardBtn = document.getElementById('card-btn');
  const cashBtn = document.getElementById('pay-btn'); // your cash button id
  if (!cardBtn || !cashBtn) return;

  const platform = isPlatformOrder(); // deliveroo / justeat

  cardBtn.disabled = platform;
  cashBtn.disabled = platform;

  cardBtn.style.opacity = platform ? '0.5' : '1';
  cashBtn.style.opacity = platform ? '0.5' : '1';
}

function syncPlatformBtnState() {
  if (!platformBtn) return;
  const on = isPlatformOrder();
  platformBtn.disabled = !on;
  platformBtn.style.opacity = on ? '1' : '0.5';
}

const unpaidBtn = document.getElementById('unpaid-btn');

function canUnpaidOrder() {
  const v = orderTypeSelect ? orderTypeSelect.value : '';
  return v === 'dine-in' || v === 'onsite' || v === 'tel';
}

function syncUnpaidBtnState() {
  if (!unpaidBtn) return;
  const on = canUnpaidOrder();
  unpaidBtn.disabled = !on;
  unpaidBtn.style.opacity = on ? '1' : '0.5';
}

// âœ… Initial state (run AFTER unpaidBtn exists)
syncUnpaidBtnState();
syncPayButtonsByType();
syncPlatformBtnState();

// make sure both Add + Unpaid update when type changes
if (orderTypeSelect) {
  orderTypeSelect.addEventListener('change', () => {
    syncPlatformBtnState();
    syncUnpaidBtnState();
    syncPayButtonsByType();   // âœ… add this
  });
}
syncUnpaidBtnState();

// ----------------------
// Cash pay button (opens popup)
// ----------------------
payBtn.addEventListener('click', () => {
  if (!order.length) {
    alert('No items in the order.');
    return;
  }

  // âœ… Auto apply cash discount + show â€œCash 5%â€ line in summary
  isCash = true;

  // keep the header toggle button visually in sync (optional)
  const cashBtnEl = document.getElementById('cash-btn');
  if (cashBtnEl) cashBtnEl.classList.add('active');

  updateOrder(); // so â€œCash 5%: -Â£x.xxâ€ shows before popup
  renderCustomerView();

  // cash total shown with 1 decimal
  amountDueEl.textContent = 'Â£' + lastFinalTotal.toFixed(1);

  amountInput.value = '';
  changeEl.textContent = 'Â£0.00';
  changeEl.parentElement.classList.remove('negative');

  payModal.style.display = 'flex';
  amountInput.focus();
});

// live change calculation for cash popup
amountInput.addEventListener('input', () => {
  const val = parseFloat(amountInput.value);

  if (isNaN(val)) {
    changeEl.textContent = 'Â£0.00';
    changeEl.parentElement.classList.remove('negative');
    return;
  }

  const change = val - lastFinalTotal;
  changeEl.textContent = 'Â£' + change.toFixed(2);

  if (change < 0) {
    changeEl.parentElement.classList.add('negative');
  } else {
    changeEl.parentElement.classList.remove('negative');
  }
});

// âœ… Quick cash preset buttons (MOVED OUTSIDE so it works immediately)
document.querySelectorAll('#pay-modal .preset-btn').forEach(btn => {
  btn.addEventListener('click', () => {

const mode = getMode();
if (mode === 'customer') {
  const allowed = new Set(['customer', 'waitlist']);
  const key = btn.dataset.tab;
  if (!allowed.has(key)) return;
}    

const v = btn.dataset.val;

    if (v === 'exact') {
      amountInput.value = String(lastFinalTotal.toFixed(2));
    } else {
      amountInput.value = v;
    }

    // Trigger existing change calculation
    amountInput.dispatchEvent(new Event('input'));
    amountInput.focus();
  });
});

payCancel.addEventListener('click', () => {
  payModal.style.display = 'none';

  // revert cash mode if payment cancelled
  isCash = false;
  const cashBtnEl = document.getElementById('cash-btn');
  if (cashBtnEl) cashBtnEl.classList.remove('active');
  updateOrder();
  renderCustomerView();
});

// confirm cash payment â†’ uses finalizeOrder('cash')
payConfirm.addEventListener('click', () => {
  const val = parseFloat(amountInput.value);
  if (isNaN(val)) {
    alert('Please enter the cash received.');
    return;
  }

  const change = val - lastFinalTotal;
  if (change < 0) {
    alert('Cash received is not enough.');
    return;
  }

  finalizeOrder('cash');
});

// ----------------------
// STEP 5: Supabase â€“ save paid orders to `orders` table
// ----------------------
// This helper takes the `ticket` object we already build in finalizeOrder()
// and sends a *copy* of it to the Supabase `orders` table.
// It uses the global `supabaseClient` that you created in <head>.
async function saveOrderToSupabase(ticket) {
  // If Supabase isn't loaded for some reason, fail safely and keep POS working.
  if (typeof supabaseClient === 'undefined') {
    console.warn('Supabase client not found â€“ skipping remote save.');
    return;
  }

  try {
    const { error } = await supabaseClient
      .from('orders')
      .insert({
        // We let Supabase generate its own `id` (uuid PK), so we do NOT send ticket.id here.

        // These column names must match the columns you created in Supabase:
        // order_number (text), service_type (text), channel (text),
        // created_at (timestamptz), payment_status (text),
        // payment_method (text), paid_at (timestamptz),
        // amount (numeric), items (jsonb).
        // âœ… do NOT send order_number; leave it out so the trigger can fill it
        service_type: ticket.serviceType,
        channel: ticket.channel,
        created_at: ticket.createdAt,
        payment_status: ticket.paymentStatus, // e.g. 'paid'
        payment_method: ticket.paymentMethod, // 'cash' | 'card' | 'deliveroo' | 'justeat'
        paid_at: ticket.paidAt,
        amount: ticket.amount,

        // Combine food + drink items into one JSON array for the `items` jsonb column.
        items: [
          ...(ticket.foodItems || []),
          ...(ticket.drinkItems || [])
        ].map(it => ({
          // Keep only the bits we care about later (for reports).
          name: it.displayName || it.name || '',
          category: it.cat || '',                  // å’–å–±ç³»åˆ— / é£²å“ / ä¸»é£Ÿ / ...
          amount: Number(it.final ?? it.price ?? 0) || 0
        }))
      });

    if (error) {
      // Log the error, but do NOT block the POS â€“ order still exists locally.
      console.error('Supabase insert error:', error.message);
    }
  } catch (err) {
    // Catch any network / unexpected error so the app never crashes.
    console.error('Unexpected Supabase error:', err);
  }
}

// ğŸ”„ Save updated item statuses back into Supabase
async function saveTicketItemsToSupabase(orderObj) {
  try {
    if (!orderObj || !orderObj.supabaseId) return; // no DB row? stop

    // Build a flat array for Supabase (food + drink together)
    const allItems = [
      ...(orderObj.foodItems || []),
      ...(orderObj.drinkItems || [])
    ].map(it => ({
      name: it.displayName || it.name || '',
      category: it.cat || '',
      amount: Number(it.final ?? it.price ?? 0) || 0,
      status: it.status || 'in-progress'
    }));

    const { error } = await supabaseClient
      .from('orders')
      .update({ items: allItems })
      .eq('id', orderObj.supabaseId);

    if (error) {
      console.error('âŒ Failed to sync item statuses to Supabase:', error.message);
    }
  } catch (err) {
    console.error('âŒ Unexpected Supabase error:', err);
  }
}

// ----------------------
// Shared finalise logic (cash + card)
// ----------------------
function finalizeOrder(paymentMethod, overrideTotal = null) {
  // If we are paying an existing Unpaid ticket, do NOT create a new kitchen ticket
  if (payingOrderId) {
    payExistingTicket(paymentMethod, overrideTotal);
    return;
  }

  if (!order.length) {
    alert('No items in the order.');
    return;
  }

  // Card/platform should not apply cash discount
  if (paymentMethod === 'card' || paymentMethod === 'deliveroo' || paymentMethod === 'justeat') {
    isCash = false;
    updateOrder();
  }

  const orderNumberInput = document.getElementById('order-number');
  const pickupInput = document.getElementById('pickup-time');

  const rawTable = orderNumberInput ? orderNumberInput.value.trim() : '';
  const orderNumber = rawTable || `#${nextOrderId++}`;

  const serviceType = orderTypeSelect ? orderTypeSelect.value : 'dine-in';

  let channel = pickupInput ? pickupInput.value.trim() : '';
  if (channel.length >= 5) channel = channel.slice(0, 5);

  const now = new Date();
  const createdAt = now.toISOString();
  const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
  const orderId = now.getTime();

  const foodCats = ['å’–å–±ç³»åˆ—', 'èŒ¶è¨˜ç²‰é¢', 'ä¸»é£Ÿ', 'å°é£Ÿ'];

  const foodItems = order
    .filter(item => foodCats.includes(item.cat))
    .map(item => ({ ...item, status: 'in-progress' }));

  const drinkItems = order
    .filter(item => item.cat === 'é£²å“')
    .map(item => ({ ...item, status: 'in-progress' }));

  const paidTotal = (typeof overrideTotal === 'number') ? overrideTotal : lastFinalTotal;

  // â­ table number = what you typed in the POS
  const tableNumber = orderNumber;

  const ticket = {
    id: orderId,

  // â­ keep orderNumber but ALSO store tableNumber
    orderNumber,
    tableNumber,

    serviceType,
    channel,
    time: timeStr,
    createdAt,

    paymentStatus: 'paid',
    paymentMethod,
    paidAt: createdAt,

    amount: paidTotal,
    foodItems,
    drinkItems
  };

  kitchenOrders.push(ticket);

  // STEP 5: also save this paid order to Supabase in the background.
  // We don't `await` here so the POS stays responsive even if the network is slow.
  saveOrderToSupabase(ticket);

// Record to CSV source (paid orders only) â€” now includes item lines
completedOrders.push({
  id: orderId,
  orderNumber,
  serviceType,
  channel,
  createdAt,
  completedAt: null,
  paidAt: createdAt,
  paymentMethod,
  total: paidTotal,
  items: [
    ...(foodItems || []),
    ...(drinkItems || [])
  ].map(it => ({
    name: it.displayName || it.name || '',
    category: it.cat || '',
    amount: Number(it.final ?? it.price ?? 0) || 0
  }))
});

  // clear POS
  order = [];
  isCash = false;
  payingOrderId = null;
  updateOrder();

  if (orderNumberInput) orderNumberInput.value = '';
  if (pickupInput) pickupInput.value = '';

  payModal.style.display = 'none';

  renderKitchenView();
  renderBarView();
  renderAllOrdersView();

if (adminUnlocked) renderAdminView();
}

// ----------------------
// Card button (NO popup) â€“ just finalise immediately
// ----------------------
if (cardBtn) {
  cardBtn.addEventListener('click', () => {
    // allow paying an existing unpaid ticket even if POS draft is empty
    if (!order.length && !payingOrderId) {
      alert('No items in the order.');
      return;
    }

    isCash = false;
    updateOrder();
    finalizeOrder('card');
  });
}

if (unpaidBtn) {
  unpaidBtn.addEventListener('click', createUnpaidTicketFromCurrentOrder);
}

if (platformBtn) {
  platformBtn.addEventListener('click', () => {
    if (!order.length) {
      alert('No items in the order.');
      return;
    }

    if (!isPlatformOrder()) {
      alert('This button is only for Deliveroo / Just Eat orders.');
      return;
    }

    // âœ… No popup â€“ use POS-calculated total
    isCash = false;
    const cashBtnEl = document.getElementById('cash-btn');
    if (cashBtnEl) cashBtnEl.classList.remove('active');
    updateOrder();
    finalizeOrder(orderTypeSelect.value, lastFinalTotal);
  });
}

// ----------------------
// Tab switching (uses data-tab, not data-view)
// ----------------------
function switchToView(viewId) {
  // Admin lock (only if switching to admin)
  if (viewId === 'admin-view') {
    if (!adminUnlocked) {
      const pw = prompt('Enter Admin password:');
      if (pw !== ADMIN_PASSWORD) return; // stop switch
      adminUnlocked = true;
    }
  } else {
    // auto-lock admin when leaving Admin
    adminUnlocked = false;

    // ğŸ’¾ Remember this view as the active tab on THIS device
  localStorage.setItem('lionrock_pos_active_tab', viewId);

  // ... your existing code that:
  // - hides all views
  // - shows the target view
  // - updates active tab button styles, etc.
  }

  // Tab active state
  document.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
  const activeBtn = document.querySelector(`.tab[data-tab="${viewId}"]`);
  if (activeBtn) activeBtn.classList.add('active');

  // Show/hide views
  const views = ['pos-view', 'kitchen-view', 'bar-view', 'all-orders-view', 'customer-view', 'admin-view', 'waitlist-view'];
  views.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.style.display = (id === viewId) ? (id === 'pos-view' ? 'flex' : 'block') : 'none';
  });

  // Render the view if needed
  if (viewId === 'customer-view') renderCustomerView();
  if (viewId === 'waitlist-view') renderWaitlist();
  if (viewId === 'admin-view') renderAdminView();
  if (viewId === 'kitchen-view') renderKitchenView();
  if (viewId === 'bar-view') renderBarView();
  if (viewId === 'all-orders-view') renderAllOrdersView();
}

document.querySelectorAll('.tab').forEach(btn => {
  btn.addEventListener('click', () => {
    const viewId = btn.dataset.tab; // âœ… correct attribute
    if (!viewId) return;
    switchToView(viewId);
  });
});

// ----------------------
// Kitchen/bar ticket line renderer (with Complete button)
// ----------------------
function renderTicketItemLine(item, orderId, index, kind) {
  const modsArray = Array.isArray(item.mods) ? item.mods : [];
  const modsHtml = modsArray.length
    ? `<div class="ticket-mods">${modsArray.join(', ')}</div>`
    : '';

  const isDone = item.status === 'complete';

  let name = item.displayName || '';
  if (item.isSetMeal) {
    name += ' <span class="blue">é¤</span>';
  }

  return `
    <div class="ticket-item ${isDone ? 'done' : ''}">
      <div class="ticket-item-main">
        <div class="ticket-item-name">${name}</div>
        ${modsHtml}
      </div>
      <button
        type="button"
        class="ticket-status-btn ${isDone ? 'done' : ''}"
        data-order-id="${orderId}"
        data-index="${index}"
        data-kind="${kind}"
      >
        ${isDone ? 'Done' : 'Complete'}
      </button>
    </div>
  `;
}

// ----------------------
// Kitchen view (food only)
// ----------------------
function renderKitchenView() {
  const wrap = document.getElementById('kitchen-orders');
  if (!wrap) return;

  let html = '';

  kitchenOrders.forEach(orderObj => {
    if (!orderObj.foodItems || !orderObj.foodItems.length) return;

const ticketClass =
  orderObj.serviceType === 'deliveroo' ? 'ticket ticket-deliveroo' :
  orderObj.serviceType === 'justeat'   ? 'ticket ticket-justeat'   :
  orderObj.serviceType === 'onsite'    ? 'ticket ticket-onsite'    :
  orderObj.serviceType === 'tel'       ? 'ticket ticket-tel'       :
  'ticket';

    html += `
      <div class="${ticketClass}">
        <div class="ticket-header">

          <!-- â­ BIG table number -->
          <div class="ticket-table">
            TABLE ${orderObj.tableNumber || '-'}
          </div>

          <!-- â­ small meta block (order#, time, type) -->
          <div class="ticket-meta">
            <div class="order-number">${orderObj.orderNumber || ''}</div>
            <div class="badge">${
              orderObj.serviceType === 'dine-in'  ? 'å ‚é£Ÿ' :
              orderObj.serviceType === 'onsite'   ? 'ç¾å ´å¤–è³£'  :
              orderObj.serviceType === 'tel'      ? 'é›»è©±å¤–è³£' :
              orderObj.serviceType === 'deliveroo'? 'Deliveroo' :
              orderObj.serviceType === 'justeat'  ? 'Just Eat' :
              orderObj.serviceType || ''
            }</div>
            <div class="ticket-time">${orderObj.time}</div>
          </div>

        </div>
        <div class="ticket-body">
          ${
           orderObj.foodItems
             .map((item, idx) => renderTicketItemLine(item, orderObj.id, idx, 'food'))
             .join('')
           }
         </div>
       </div>
    `;
  });

  wrap.innerHTML = html || '<p style="text-align:center;color:#999;">No kitchen orders</p>';
}

// ----------------------
// Bar view (drinks only)
// ----------------------
function renderBarView() {
  const wrap = document.getElementById('bar-orders');
  if (!wrap) return;

  let html = '';

  kitchenOrders.forEach(orderObj => {
    if (!orderObj.drinkItems || !orderObj.drinkItems.length) return;

const ticketClass =
  orderObj.serviceType === 'deliveroo' ? 'ticket ticket-deliveroo' :
  orderObj.serviceType === 'justeat'   ? 'ticket ticket-justeat'   :
  orderObj.serviceType === 'onsite'    ? 'ticket ticket-onsite'    :
  orderObj.serviceType === 'tel'       ? 'ticket ticket-tel'       :
  'ticket';

    html += `
      <div class="${ticketClass}">
        <div class="ticket-header">

          <!-- â­ BIG table number -->
          <div class="ticket-table">
            TABLE ${orderObj.tableNumber || '-'}
          </div>

          <!-- â­ small meta block (order#, time, type) -->
          <div class="ticket-meta">
            <div class="order-number">${orderObj.orderNumber || ''}</div>
            <div class="badge">${
              orderObj.serviceType === 'dine-in'  ? 'å ‚é£Ÿ' :
              orderObj.serviceType === 'onsite'   ? 'ç¾å ´å¤–è³£'  :
              orderObj.serviceType === 'tel'      ? 'é›»è©±å¤–è³£' :
              orderObj.serviceType === 'deliveroo'? 'Deliveroo' :
              orderObj.serviceType === 'justeat'  ? 'Just Eat' :
              orderObj.serviceType || ''
            }</div>
            <div class="ticket-time">${orderObj.time}</div>
          </div>

        </div>
        <div class="ticket-body">
          ${
            orderObj.drinkItems
             .map((item, idx) => renderTicketItemLine(item, orderObj.id, idx, 'drink'))
             .join('')
           }
        </div>
       </div>
    `;
  });

  wrap.innerHTML = html || '<p style="text-align:center;color:#999;">No bar orders</p>';
}

// ----------------------
// ALL ORDERS view (overview, NO complete buttons)
// + Retrieve button for archived orders
// ----------------------
function renderAllOrdersView() {
  const wrap = document.getElementById('all-orders');
  if (!wrap) return;

  let html = '';

function getTicketClass(orderObj) {
  if (orderObj.serviceType === 'deliveroo') return 'ticket ticket-deliveroo';
  if (orderObj.serviceType === 'justeat')   return 'ticket ticket-justeat';
  if (orderObj.serviceType === 'onsite')    return 'ticket ticket-onsite';
  if (orderObj.serviceType === 'tel')       return 'ticket ticket-tel';
  return 'ticket';
}

  function renderStatusBadgeType(orderObj) {
    return orderObj.serviceType === 'dine-in'  ? 'å ‚é£Ÿ' :
           orderObj.serviceType === 'onsite'   ? 'ç¾å ´å¤–è³£'  :
           orderObj.serviceType === 'tel'      ? 'é›»è©±å¤–è³£' :
           orderObj.serviceType === 'deliveroo'? 'Deliveroo' :
           orderObj.serviceType === 'justeat'  ? 'Just Eat' :
           orderObj.serviceType || '';
  }

    function renderOverviewCard(orderObj, statusLabel, isArchived) {
    const allItems = [];

    (orderObj.foodItems || []).forEach((item, idx) => {
      allItems.push({ item, kind: 'food', index: idx });
    });
    (orderObj.drinkItems || []).forEach((item, idx) => {
      allItems.push({ item, kind: 'drink', index: idx });
    });

    if (!allItems.length) return '';

    const isPendingPay = (orderObj.paymentStatus === 'pending');

    const paymentBadge = isPendingPay
      ? `<span class="badge badge-pending">Pending for payment</span>`
      : `<span class="badge badge-paid">Paid</span>`;

    const payBtnHtml = isPendingPay
      ? `<button type="button" class="pay-pending-btn" data-order-id="${orderObj.id}">Pay</button>`
      : '';

    const itemsHtml = allItems.map(entry => {
      const it   = entry.item;
      const kind = entry.kind;
      const idx  = entry.index;

      const modsArray = Array.isArray(it.mods) ? it.mods : [];
      const modsHtml = modsArray.length
        ? `<div class="ticket-mods">${modsArray.join(', ')}</div>`
        : '';

      let name = it.displayName || '';
      if (it.isSetMeal) name += ' <span class="blue">é¤</span>';

      const isComplete = it.status === 'complete';
      const itemClass = isComplete ? 'ticket-item done' : 'ticket-item';

      const retrieveBtnHtml = isComplete
        ? `<button
             type="button"
             class="retrieve-btn"
             data-order-id="${orderObj.id}"
             data-kind="${kind}"
             data-index="${idx}"
             data-archived="${isArchived ? '1' : '0'}"
           >Retrieve</button>`
        : '';

      const editBtnHtml = (!isArchived)
        ? `
          <button
            type="button"
            class="edit-btn ticket-edit-btn"
            title="Edit"
            data-ticket-id="${orderObj.id}"
            data-kind="${kind}"
            data-index="${idx}"
            data-archived="0"
          >
            <i class="fas fa-pen"></i>
          </button>
        `
        : '';

      return `
        <div class="${itemClass}">
          <div class="ticket-item-main">
            <div class="ticket-item-name">${name}</div>
            ${modsHtml}
          </div>
          <div class="ticket-item-actions">
            ${editBtnHtml}
            ${retrieveBtnHtml}
          </div>
        </div>
      `;
    }).join('');

    return `
      <div class="${getTicketClass(orderObj)}">
        <div class="ticket-header">

          <!-- â­ BIG table number -->
          <div class="ticket-table">
            TABLE ${orderObj.tableNumber || '-'}
          </div>

          <!-- â­ right-side meta (order#, status, type, payment, time) -->
          <div class="ticket-meta">
            <div class="order-number">${orderObj.orderNumber || ''}</div>
            <div>
              <span class="badge">${statusLabel}</span>
              <span class="badge">${renderStatusBadgeType(orderObj)}</span>
              ${orderObj.channel ? `<span class="badge">Pickup ${orderObj.channel}</span>` : ''}
            </div>
            <div>
              ${paymentBadge}
              ${payBtnHtml}
            </div>
            <div class="ticket-time">${orderObj.time || ''}</div>
          </div>

        </div>

        <div class="ticket-body">
          ${itemsHtml}
        </div>
      </div>
    `;
  }

  // Active (still in kitchenOrders)
  kitchenOrders.forEach(o => {
    html += renderOverviewCard(o, 'In progress', false);
  });

  // Fully completed / archived
  archivedOrders.forEach(o => {
    html += renderOverviewCard(o, 'Completed', true);
  });

  wrap.innerHTML = html || '<p style="text-align:center;color:#999;">No orders</p>';
}

function bucketFromCategory(cat) {
  const c = String(cat || '');
  if (c.includes('é£²å“')) return 'drink';
  if (c.includes('å°é£Ÿ')) return 'snack';
  return 'food';
}

function buildBucketPivot(itemRows) {
  const buckets = { food: [], drink: [], snack: [] };

  itemRows.forEach(r => {
    const b = bucketFromCategory(r.category);
    buckets[b].push(r);
  });

  // Sort each bucket by qty desc
  Object.keys(buckets).forEach(k => {
    buckets[k].sort((a, b) => b.qty - a.qty);
  });

  return buckets;
}

function renderAdminView() {
  const wrap = document.getElementById('admin-summary');
  const dateInput = document.getElementById('admin-date');
  if (!wrap || !dateInput) return;

  // default date = today
  if (!dateInput.value) {
    const now = new Date();
    const yyyy = now.getFullYear();
    const mm = String(now.getMonth() + 1).padStart(2, '0');
    const dd = String(now.getDate()).padStart(2, '0');
    dateInput.value = `${yyyy}-${mm}-${dd}`;
  }

  const selected = dateInput.value; // yyyy-mm-dd

  // filter by paidAt date (local)
  const todays = completedOrders.filter(o => {
    const iso = o.paidAt || o.createdAt || '';
    if (!iso) return false;
    const d = new Date(iso);
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, '0');
    const dd = String(d.getDate()).padStart(2, '0');
    return `${yyyy}-${mm}-${dd}` === selected;
  });

  // âœ… Build item pivot: { "item name": { qty, amount } }
const itemMap = new Map();

todays.forEach(o => {
  const items = Array.isArray(o.items) ? o.items : [];
  items.forEach(it => {
    const key = (it.name || '').trim();
    if (!key) return;

    const prev = itemMap.get(key) || { qty: 0, amount: 0, category: it.category || '' };
    prev.qty += 1;
    prev.amount += (Number(it.amount || 0) || 0);
    if (!prev.category && it.category) prev.category = it.category;
    itemMap.set(key, prev);
  });
});

// turn into sorted array (most sold first)
const itemRows = Array.from(itemMap.entries())
  .map(([name, v]) => ({ name, qty: v.qty, amount: v.amount, category: v.category || '' }))
  .sort((a, b) => b.qty - a.qty);

const buckets = buildBucketPivot(itemRows);

  const sum = {
    cash: 0,
    card: 0,
    deliveroo: 0,
    justeat: 0,
    total: 0
  };

  todays.forEach(o => {
    const amt = Number(o.total || 0) || 0;
    sum.total += amt;

    const m = (o.paymentMethod || '').toLowerCase();
    if (m === 'cash') sum.cash += amt;
    else if (m === 'card') sum.card += amt;
    else if (m === 'deliveroo') sum.deliveroo += amt;
    else if (m === 'justeat') sum.justeat += amt;
  });

wrap.innerHTML = `
  <!-- ===== Summary cards ===== -->
  <div class="ticket-grid" style="grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:12px;">
    <div class="ticket">
      <div class="ticket-header">Cash</div>
      <div class="ticket-body"><strong>Â£${sum.cash.toFixed(2)}</strong></div>
    </div>

    <div class="ticket">
      <div class="ticket-header">Card</div>
      <div class="ticket-body"><strong>Â£${sum.card.toFixed(2)}</strong></div>
    </div>

    <div class="ticket">
      <div class="ticket-header">Deliveroo</div>
      <div class="ticket-body"><strong>Â£${sum.deliveroo.toFixed(2)}</strong></div>
    </div>

    <div class="ticket">
      <div class="ticket-header">Just Eat</div>
      <div class="ticket-body"><strong>Â£${sum.justeat.toFixed(2)}</strong></div>
    </div>

    <div class="ticket">
      <div class="ticket-header">Total</div>
      <div class="ticket-body"><strong>Â£${sum.total.toFixed(2)}</strong></div>
    </div>
  </div>

  <!-- ===== Todayâ€™s Item Sales (FULL WIDTH, BELOW GRID) ===== -->
  <!-- ===== Todayâ€™s Item Sales (TABLES ONLY) ===== -->
  <div class="ticket" style="margin-top:16px;">
    <div class="ticket-header"><strong>Todayâ€™s Item Sales</strong></div>
    <div class="ticket-body">

      ${itemRows.length ? `
        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap:16px;">

          <!-- Food -->
          <div>
            <div style="font-weight:800; margin-bottom:8px;">Food</div>
            <div style="display:grid; grid-template-columns: 2fr 1fr 1fr; font-weight:700; border-bottom:1px solid #ddd; padding-bottom:6px;">
              <div>Item</div><div>Qty</div><div>Â£</div>
            </div>
            ${buckets.food.map(r => `
              <div style="display:grid; grid-template-columns: 2fr 1fr 1fr; padding:6px 0; border-bottom:1px solid #f0f0f0;">
                <div>${r.name}</div>
                <div>${r.qty}</div>
                <div>Â£${r.amount.toFixed(2)}</div>
              </div>
            `).join('') || `<div style="color:#777; padding:8px 0;">No food items</div>`}
          </div>

          <!-- Drinks -->
          <div>
            <div style="font-weight:800; margin-bottom:8px;">Drinks</div>
            <div style="display:grid; grid-template-columns: 2fr 1fr 1fr; font-weight:700; border-bottom:1px solid #ddd; padding-bottom:6px;">
              <div>Item</div><div>Qty</div><div>Â£</div>
            </div>
            ${buckets.drink.map(r => `
              <div style="display:grid; grid-template-columns: 2fr 1fr 1fr; padding:6px 0; border-bottom:1px solid #f0f0f0;">
                <div>${r.name}</div>
                <div>${r.qty}</div>
                <div>Â£${r.amount.toFixed(2)}</div>
              </div>
            `).join('') || `<div style="color:#777; padding:8px 0;">No drink items</div>`}
          </div>

          <!-- Snacks -->
          <div>
            <div style="font-weight:800; margin-bottom:8px;">Snacks</div>
            <div style="display:grid; grid-template-columns: 2fr 1fr 1fr; font-weight:700; border-bottom:1px solid #ddd; padding-bottom:6px;">
              <div>Item</div><div>Qty</div><div>Â£</div>
            </div>
            ${buckets.snack.map(r => `
              <div style="display:grid; grid-template-columns: 2fr 1fr 1fr; padding:6px 0; border-bottom:1px solid #f0f0f0;">
                <div>${r.name}</div>
                <div>${r.qty}</div>
                <div>Â£${r.amount.toFixed(2)}</div>
              </div>
            `).join('') || `<div style="color:#777; padding:8px 0;">No snack items</div>`}
          </div>

        </div>
      ` : `
        <div style="color:#777;">No paid orders for this date.</div>
      `}

    </div>
  </div>

  <p style="color:#666;margin-top:10px;">
    Orders counted: <strong>${todays.length}</strong>
  </p>
`;
}

// ----------------------
// Kitchen/bar Complete button handler
// ----------------------
async function handleTicketClick(e) {
  const btn = e.target.closest('.ticket-status-btn');
  if (!btn) return;

  const orderId = Number(btn.dataset.orderId);
  const index   = Number(btn.dataset.index);
  const kind    = btn.dataset.kind;

  if (!orderId || Number.isNaN(index)) return;

  const orderObj = kitchenOrders.find(o => o.id === orderId);
  if (!orderObj) return;

  const items = (kind === 'food') ? orderObj.foodItems : orderObj.drinkItems;
  const item  = items[index];
  if (!item) return;

  // Toggle status
  item.status = (item.status === 'complete') ? 'in-progress' : 'complete';

  // 2ï¸âƒ£ Maybe move/remove ticket if everything done
  // (your existing logic here)

  // 3ï¸âƒ£ ğŸ”„ Sync to Supabase
  await saveTicketItemsToSupabase(orderObj);

  const allFoodDone  = !orderObj.foodItems.length || orderObj.foodItems.every(i => i.status === 'complete');
  const allDrinkDone = !orderObj.drinkItems.length || orderObj.drinkItems.every(i => i.status === 'complete');

// If everything is complete â†’ move order to archivedOrders and stamp completion time
if (allFoodDone && allDrinkDone) {
  const completionTime = new Date().toISOString();

  // remove from active
  kitchenOrders = kitchenOrders.filter(o => o.id !== orderId);

  // store in archivedOrders with completion timestamp
  orderObj.completedAt = completionTime;
  archivedOrders.push(orderObj);

  // also attach completion time to completedOrders entry for CSV
  const summary = completedOrders.find(o => o.id === orderId);
  if (summary) {
    summary.completedAt = completionTime;
  }
}

  renderKitchenView();
  renderBarView();
  renderAllOrdersView();
}

// kitchen & bar listen for Complete/Done
document.getElementById('kitchen-orders').addEventListener('click', handleTicketClick);
document.getElementById('bar-orders').addEventListener('click', handleTicketClick);

// All orders click delegation: Pay (whole order) + Retrieve (per item)
document.getElementById('all-orders').addEventListener('click', e => {

  // âœ… EDIT (per item) in All Orders
  const editBtn = e.target.closest('.ticket-edit-btn');
  if (editBtn) {
    const orderId = Number(editBtn.dataset.ticketId);
    const index = Number(editBtn.dataset.index);
    const kind = editBtn.dataset.kind; // 'food' or 'drink'
    const isArchived = editBtn.dataset.archived === '1';

    if (!orderId || Number.isNaN(index)) return;

    const collection = isArchived ? archivedOrders : kitchenOrders;
    const ticket = collection.find(o => o.id === orderId);
    if (!ticket) return;

    const items = (kind === 'food') ? ticket.foodItems : ticket.drinkItems;
    const it = items[index];
    if (!it) return;

    // remember what we are editing (so modal saves back to ticket item)
    editingTicketItem = { ticketId: ticket.id, lane: kind, index };

    // find matching menu item to open correct option groups
    let menuIndex = (typeof it.menuIndex === 'number') ? it.menuIndex : -1;
    if (menuIndex < 0) {
      const baseName = (it.displayName || '').replace(/^(ç†±|å‡)/, '');
      menuIndex = menu.findIndex(m => m.name === baseName);
    }
    if (menuIndex < 0) {
      alert('Cannot edit this item (no matching menu entry found).');
      editingTicketItem = null;
      return;
    }

    // open the SAME modal you already use
    editingOrderItemIndex = null; // important: do NOT edit current POS order[]
    openModal(menu[menuIndex], menuIndex);
    return;
  }  

// âœ… PAY (whole order)
  const payBtn = e.target.closest('.pay-pending-btn');
  if (payBtn) {
    const orderId = Number(payBtn.dataset.orderId);
    if (!orderId) return;

    const ticket = findTicketById(orderId);
    if (!ticket) return;

    // Load ticket into POS for cashier to take payment
    order = [
      ...(ticket.foodItems || []),
      ...(ticket.drinkItems || [])
    ].map(it => ({
      ...it,
      mods: Array.isArray(it.mods) ? it.mods : [],
      final: Number(it.final ?? it.price ?? 0)
    }));

    payingOrderId = ticket.id;

    // Switch to POS tab
    document.querySelector('[data-tab="pos-view"]').click();

    isCash = false;
    updateOrder();
    renderCustomerView();
    return; // IMPORTANT: stop here so it doesn't run Retrieve logic
  }

  // âœ… RETRIEVE (per item)
  const btn = e.target.closest('.retrieve-btn');
  if (!btn) return;

  const orderId = Number(btn.dataset.orderId);
  const index = Number(btn.dataset.index);
  const kind = btn.dataset.kind;
  const isArchived = btn.dataset.archived === '1';

  if (!orderId || Number.isNaN(index)) return;

  const collection = isArchived ? archivedOrders : kitchenOrders;
  const orderObj = collection.find(o => o.id === orderId);
  if (!orderObj) return;

  const items = (kind === 'food') ? orderObj.foodItems : orderObj.drinkItems;
  const item = items[index];
  if (!item) return;

  item.status = 'in-progress';

  // If it was archived, move it back to active kitchenOrders
  if (isArchived) {
    archivedOrders = archivedOrders.filter(o => o.id !== orderId);
    kitchenOrders.push(orderObj);
  }

  renderKitchenView();
  renderBarView();
  renderAllOrdersView();
});

// ----------------------
// CSV EXPORT
// ----------------------
function formatDateForCsv(iso) {
  if (!iso) return '';
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return '';
  const yy = String(d.getFullYear()).slice(-2);
  const mm = String(d.getMonth() + 1).padStart(2, '0');
  const dd = String(d.getDate()).padStart(2, '0');
  return `${yy}/${mm}/${dd}`;
}

function formatTimeForCsv(iso) {
  if (!iso) return '';
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return '';
  const hh = String(d.getHours()).padStart(2, '0');
  const mm = String(d.getMinutes()).padStart(2, '0');
  return `${hh}:${mm}`;
}

function mapTypeLabel(serviceType) {
  return serviceType === 'dine-in'  ? 'å ‚é£Ÿ' :
         serviceType === 'onsite'   ? 'ç¾å ´å¤–è³£' :
         serviceType === 'tel'      ? 'é›»è©±å¤–è³£' :
         serviceType === 'deliveroo'? 'Deliveroo' :
         serviceType === 'justeat'  ? 'Just Eat' :
         serviceType || '';
}

function mapPaymentLabel(method) {
  if (!method) return '';
  method = String(method).toLowerCase();
  if (method === 'cash') return 'Cash';
  if (method === 'card') return 'Card';
  if (method === 'deliveroo') return 'Deliveroo';
  if (method === 'justeat') return 'Just Eat';
  return method;
}

function exportCsv() {
  if (!completedOrders.length) {
    alert('No completed orders to export yet.');
    return;
  }

  const header = [
    'Order #',
    'Type',
    'Date (YY/MM/DD)',
    'Time (HH:MM)',
    'Complete time (HH:MM)',
    'Payment method',
    'Amount'
  ];

  const rows = [[
   'Order #',
   'Type',
   'Date (YY/MM/DD)',
   'Food item',
   'Category',
   'Time (HH:MM)',
   'Complete time (HH:MM)',
   'Payment method',
   'Amount'
 ]];

completedOrders.forEach(o => {
  const items = Array.isArray(o.items) ? o.items : [];

  // If somehow an old record has no items, you can skip or output a blank line
  if (!items.length) return;

  items.forEach(it => {
    rows.push([
      o.orderNumber || '',
      o.serviceType || '',
      formatDateForCsv(o.paidAt || o.createdAt || ''),
      it.name || '',
      it.category || '',
      formatTimeForCsv(o.createdAt || ''),
      formatTimeForCsv(o.completedAt || ''),
      o.paymentMethod || '',
      (Number(it.amount || 0) || 0).toFixed(2)
    ]);
  });
});

  const csvContent = rows
    .map(cols =>
      cols
        .map(val => `"${String(val).replace(/"/g, '""')}"`)
        .join(',')
    )
    .join('\r\n');

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'orders.csv';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// Export button listener
const exportBtn = document.getElementById('export-csv-btn');
if (exportBtn) {
  exportBtn.addEventListener('click', exportCsv);
}

// Admin refresh (daily sales)
const adminRefreshBtn = document.getElementById('admin-refresh');
const adminDateInput = document.getElementById('admin-date');

if (adminRefreshBtn) {
  adminRefreshBtn.addEventListener('click', renderAdminView);
}

if (adminDateInput) {
  adminDateInput.addEventListener('change', renderAdminView);
}

function createUnpaidTicketFromCurrentOrder() {
  if (!order.length) {
    alert('No items in the order.');
    return;
  }
  if (!canUnpaidOrder()) {
    alert('Unpaid is only for Dine-in / Onsite / Tel orders.');
    return;
  }

  // Unpaid should NOT apply cash discount
  isCash = false;
  updateOrder();

  const orderNumberInput = document.getElementById('order-number');
  const pickupInput = document.getElementById('pickup-time');

  const rawTable = orderNumberInput ? orderNumberInput.value.trim() : '';
  const orderNumber = rawTable || `#${nextOrderId++}`;

  const serviceType = orderTypeSelect ? orderTypeSelect.value : 'dine-in';

  let channel = pickupInput ? pickupInput.value.trim() : '';
  if (channel.length >= 5) channel = channel.slice(0, 5);

  const now = new Date();
  const createdAt = now.toISOString();
  const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
  const orderId = now.getTime();

  const foodCats = ['å’–å–±ç³»åˆ—', 'èŒ¶è¨˜ç²‰é¢', 'ä¸»é£Ÿ', 'å°é£Ÿ'];

  const foodItems = order
    .filter(item => foodCats.includes(item.cat))
    .map(item => ({ ...item, status: 'in-progress' }));

  const drinkItems = order
    .filter(item => item.cat === 'é£²å“')
    .map(item => ({ ...item, status: 'in-progress' }));

  const ticket = {
    id: orderId,
    orderNumber,
    serviceType,
    channel,
    time: timeStr,
    createdAt,

    paymentStatus: 'pending',
    paymentMethod: null,
    paidAt: null,

    amount: lastFinalTotal, // snapshot total for later payment/CSV
    foodItems,
    drinkItems
  };

  kitchenOrders.push(ticket);

  // clear POS
  order = [];
  isCash = false;
  payingOrderId = null;
  updateOrder();

  if (orderNumberInput) orderNumberInput.value = '';
  if (pickupInput) pickupInput.value = '';

  renderKitchenView();
  renderBarView();
  renderAllOrdersView();
}

function findTicketById(orderId) {
  return kitchenOrders.find(o => o.id === orderId) || archivedOrders.find(o => o.id === orderId) || null;
}

function payExistingTicket(method, overrideTotal = null) {
  const ticket = findTicketById(payingOrderId);
  if (!ticket) {
    payingOrderId = null;
    return;
  }

  // mark paid on ticket itself (kitchen/archived)
  ticket.paymentStatus = 'paid';
  ticket.paymentMethod = method;
  ticket.paidAt = new Date().toISOString();

  const paidTotal = (typeof overrideTotal === 'number') ? overrideTotal : (ticket.amount ?? lastFinalTotal);

completedOrders.push({
  id: ticket.id,
  orderNumber: ticket.orderNumber,
  serviceType: ticket.serviceType,
  channel: ticket.channel,
  createdAt: ticket.createdAt,
  completedAt: ticket.completedAt || null,
  paidAt: ticket.paidAt,
  paymentMethod: method,
  total: paidTotal,

  // âœ… NEW: store items for CSV + admin pivot
  items: [
    ...(ticket.foodItems || []),
    ...(ticket.drinkItems || [])
  ].map(it => ({
    name: it.displayName || it.name || '',
    category: it.cat || '',
    amount: Number(it.final ?? it.price ?? 0) || 0
  }))
});

  // clear POS
  payingOrderId = null;
  order = [];
  isCash = false;
  updateOrder();

  if (payModal) payModal.style.display = 'none';

  renderAllOrdersView();
  renderKitchenView();
  renderBarView();

if (adminUnlocked) renderAdminView();
}

function renderCustomerView() {
  const wrap = document.getElementById('customer-screen');
  if (!wrap) return;

  const orderNumberInput = document.getElementById('order-number');
  const pickupInput = document.getElementById('pickup-time');
  const subtotal = order.length ? lastSubtotal : 0;
  const baseTotal = order.length ? lastBaseTotal : 0;     // after combo discount
  const finalTotal = order.length ? lastFinalTotal : 0;   // after cash discount (if cash)

  const comboAValue = order.length ? (lastComboACount * 0.5) : 0;
  const comboBValue = order.length ? (lastComboBCount * 1.0) : 0;

  const comboDiscountTotal = order.length ? lastMealDealDiscount : 0;
  const cashDiscountValue = (order.length && isCash) ? lastCashDiscount : 0;

  const serviceType = orderTypeSelect ? orderTypeSelect.value : '';
  const tableOrNo   = orderNumberInput ? orderNumberInput.value.trim() : '';

  let pickup = pickupInput ? pickupInput.value.trim() : '';
  if (pickup.length >= 5) pickup = pickup.slice(0,5);

  const typeLabel =
    serviceType === 'dine-in'  ? 'å ‚é£Ÿ' :
    serviceType === 'onsite'   ? 'ç¾å ´å¤–è³£' :
    serviceType === 'tel'      ? 'é›»è©±å¤–è³£' :
    serviceType === 'deliveroo'? 'Deliveroo' :
    serviceType === 'justeat'  ? 'Just Eat' :
    serviceType || '';

  const meta = [];
  if (typeLabel) meta.push(`Type: ${typeLabel}`);
  if (tableOrNo) meta.push(`Table/Order: ${tableOrNo}`);
  if (pickup) meta.push(`Pickup: ${pickup}`);

  const itemsHtml = order.length
    ? order.map(it => {
        const mods = Array.isArray(it.mods) && it.mods.length
          ? `<div class="customer-mods">${it.mods.map(m => escapeHtml(m)).join(', ')}</div>`
          : '';
        return `
          <div class="customer-item">
            <div>
              <div><strong>${escapeHtml(it.displayName)}</strong></div>
              ${mods}
            </div>
            <div>Â£${Number(it.final).toFixed(2)}</div>
          </div>
        `;
      }).join('')
    : `<div style="color:#777;">No items yet</div>`;

  wrap.innerHTML = `
    <div class="customer-title">è«‹æŸ¥çœ‹ä½ çš„è¨‚å–® Here is your order</div>
    <div class="customer-meta">
      ${meta.map(x => `<span class="customer-pill">${escapeHtml(x)}</span>`).join('')}
    </div>
    <div class="customer-card">
      ${itemsHtml}
      <div class="customer-total">
  <div>Base total</div>
  <div>Â£${baseTotal.toFixed(2)}</div>
</div>

${comboAValue > 0 ? `
<div class="customer-total" style="color:#d32f2f;">
  <div>Combo A x${lastComboACount}</div>
  <div>-Â£${comboAValue.toFixed(2)}</div>
</div>` : ''}

${comboBValue > 0 ? `
<div class="customer-total" style="color:#d32f2f;">
  <div>Combo B x${lastComboBCount}</div>
  <div>-Â£${comboBValue.toFixed(2)}</div>
</div>` : ''}

${cashDiscountValue > 0 ? `
<div class="customer-total" style="color:#d32f2f;">
  <div>Cash 5%</div>
  <div>-Â£${cashDiscountValue.toFixed(2)}</div>
</div>` : ''}

<hr style="margin:10px 0;">

<div class="customer-total" style="font-size:26px;">
  <div>Total</div>
  <div>Â£${finalTotal.toFixed(2)}</div>
</div>
    </div>
  `;
}

function renderWaitlist() {
  const countEl = document.getElementById('wl-count');
  const tbody = document.getElementById('waitlist-tbody');
  const emptyEl = document.getElementById('wl-empty');

  if (!tbody) return;

  // Count
  if (countEl) countEl.textContent = String(waitlist.length);

  // Empty state
  if (emptyEl) emptyEl.style.display = waitlist.length ? 'none' : 'block';

  // Rows
  tbody.innerHTML = '';

  const now = Date.now();

  waitlist.forEach((w, idx) => {
    const mins = Math.max(0, Math.floor((now - w.time) / 60000));
    const waitTimeText = mins < 1 ? '0 min' : `${mins} min`;

    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="wl-pos">${idx + 1}</td>
      <td><strong>${escapeHtml(w.name)}</strong></td>
      <td>${w.pax}</td>
      <td>${waitTimeText}</td>
      <td>
        <div class="wl-actions">
          <button type="button" class="wl-btn wl-btn-seat" data-seat="${idx}">å…¥åº§</button>
          <button type="button" class="wl-btn wl-btn-remove" data-remove="${idx}">ç§»é™¤</button>
        </div>
      </td>
    `;
    tbody.appendChild(tr);
  });
}

// ----------------------
// STEP 7: Load today's orders from Supabase
// ----------------------
// This pulls orders for *today* from the `orders` table and rebuilds:
// - kitchenOrders (all tickets with items still "in-progress")
// - completedOrders (for Admin/CSV summaries)
// - archivedOrders (we leave empty for now; it will be filled locally
//   when the device marks an order fully completed).
async function loadTodayOrdersFromSupabase() {
  if (typeof supabaseClient === 'undefined') {
    console.warn('Supabase client not found â€“ loading with empty orders.');
    kitchenOrders = [];
    completedOrders = [];
    archivedOrders = [];
    return;
  }

  const { start, end } = getTodayRangeISO();

  try {
    const { data, error } = await supabaseClient
      .from('orders')
      .select('*')
      .gte('created_at', start)
      .lt('created_at', end)
      .order('created_at', { ascending: true });

    if (error) {
      console.error('Failed to load today\'s orders from Supabase:', error.message);
      kitchenOrders = [];
      completedOrders = [];
      archivedOrders = [];
      return;
    }

    // Reset local state for today
    kitchenOrders = [];
    completedOrders = [];
    archivedOrders = [];

    (data || []).forEach(row => {
      const createdAt = row.created_at || new Date().toISOString();
      const paidAt    = row.paid_at   || createdAt;
      const amount    = Number(row.amount || 0) || 0;

      // Use the created_at timestamp as the numeric ticket id,
      // so it matches the id we originally used when we created the ticket.
      const orderId = Date.parse(createdAt) || Date.now();

      const rawItems = Array.isArray(row.items) ? row.items : [];

      // Rebuild food & drink arrays based on the saved item.category.
      const foodItems = [];
      const drinkItems = [];

      rawItems.forEach(it => {
        const cat = it.category || '';
        const status = it.status || 'in-progress';  // â­ read from DB

        const base = {
          displayName: it.name || '',
          name: it.name || '',
          cat,
          final: Number(it.amount || 0) || 0,
          mods: [],
          isSetMeal: false,
          status
        };

        if (cat === 'é£²å“' || cat.includes('é£²å“')) {
          drinkItems.push(base);
        } else {
          foodItems.push(base);
        }
      });

      const ticket = {
        id: orderId,
        supabaseId: row.id,   // â­ THIS LINE
        orderNumber: row.order_number || '',
        serviceType: row.service_type || 'dine-in',
        channel: row.channel || '',
        time: createdAt
          ? new Date(createdAt).toLocaleTimeString([], {
              hour: '2-digit',
              minute: '2-digit',
              hour12: false
            })
          : '',
        createdAt,
        paymentStatus: 'paid',
        paymentMethod: row.payment_method || null,
        paidAt,
        amount,
        foodItems,
        drinkItems
      };

      // Work out if everything on this ticket is already complete
      const allFoodDone  = !foodItems.length || foodItems.every(i => i.status === 'complete');
      const allDrinkDone = !drinkItems.length || drinkItems.every(i => i.status === 'complete');
      const isFullyDone  = allFoodDone && allDrinkDone;

      // For boards:
      // - Kitchen & Bar should only see tickets that still have something to cook/pour
      const hasAnyItems = foodItems.length > 0 || drinkItems.length > 0;

      if (hasAnyItems && !isFullyDone) {
        // still have at least one item NOT complete â†’ show on Kitchen/Bar boards
        kitchenOrders.push(ticket);
      } else if (hasAnyItems && isFullyDone) {
        // everything is done â†’ treat as archived on this device
        archivedOrders.push(ticket);
      }

      // For Admin & CSV export: we keep the summary in completedOrders.
      completedOrders.push({
        id: ticket.id,
        orderNumber: ticket.orderNumber,
        serviceType: ticket.serviceType,
        channel: ticket.channel,
        createdAt: ticket.createdAt,
        completedAt: null,             // we don't sync item completion yet
        paidAt: ticket.paidAt,
        paymentMethod: ticket.paymentMethod,
        total: ticket.amount,
        items: rawItems.map(it => ({
          name: it.name || '',
          category: it.category || '',
          amount: Number(it.amount || 0) || 0
        }))
      });

      // NOTE:
      // archivedOrders is intentionally left empty here.
      // It will be populated when this specific device marks all items
      // "done" in the kitchen/bar. Full cross-device sync of completion
      // state would require storing per-item status in Supabase.
    });
  } catch (err) {
    console.error('Unexpected error loading orders from Supabase:', err);
    kitchenOrders = [];
    completedOrders = [];
    archivedOrders = [];
  }
}

// ----------------------
// STEP 6: Waitlist â†’ Supabase
// ----------------------
// NOTE:
// - We now store the waitlist in the Supabase `waitlist` table instead of localStorage.
// - Table structure expected:
//   id (bigint, PK, identity)
//   name (text)
//   pax (integer)
//   created_at (timestamptz, default now())

// Save the current `waitlist` array to Supabase.
// Simple approach: clear the table then re-insert all rows.
// Called after we add / seat / remove entries.
async function saveWaitlist() {
  // If Supabase is not available for some reason, fail silently
  // so the POS doesn't break mid-service.
  if (typeof supabaseClient === 'undefined') {
    console.warn('Supabase client not found â€“ skipping waitlist save.');
    return;
  }

  try {
    // 1) Clear existing rows.
    // `neq('id', 0)` = delete all rows where id != 0 (i.e. everything).
    const { error: deleteError } = await supabaseClient
      .from('waitlist')
      .delete()
      .neq('id', 0);

    if (deleteError) {
      console.error('Failed to clear waitlist in Supabase:', deleteError.message);
      return; // stop here â€“ donâ€™t insert if delete failed
    }

    // 2) If waitlist is empty now, weâ€™re done.
    if (!waitlist.length) {
      return;
    }

    // 3) Insert all current entries.
    const rows = waitlist.map(w => ({
      name: w.name,
      pax: w.pax,
      // store the "time" as created_at so we can reconstruct wait minutes later
      created_at: new Date(w.time).toISOString()
    }));

    const { error: insertError } = await supabaseClient
      .from('waitlist')
      .insert(rows);

    if (insertError) {
      console.error('Failed to save waitlist to Supabase:', insertError.message);
    }
  } catch (err) {
    console.error('Unexpected Supabase error (waitlist save):', err);
  }
}

// Load the waitlist from Supabase into the `waitlist` array.
// Called once on startup.
async function loadWaitlist() {
  if (typeof supabaseClient === 'undefined') {
    console.warn('Supabase client not found â€“ loading empty waitlist.');
    waitlist = [];
    return;
  }

  try {
    const { data, error } = await supabaseClient
      .from('waitlist')
      .select('*')
      .order('created_at', { ascending: true });

    if (error) {
      console.error('Failed to load waitlist from Supabase:', error.message);
      waitlist = [];
      return;
    }

    // Convert DB rows into the shape used by the UI:
    // { name, pax, time: timestamp(ms) }
    waitlist = (data || []).map(row => ({
      name: row.name,
      pax: row.pax,
      time: row.created_at ? new Date(row.created_at).getTime() : Date.now()
    }));
  } catch (err) {
    console.error('Unexpected Supabase error (waitlist load):', err);
    waitlist = [];
  }
}

// ----------------------
// Waitlist history logging (optional, for analytics)
// ----------------------
// This logs every waitlist action into the `waitlist_history` table
// without changing how the on-screen waitlist behaves.
async function logWaitlistEvent(entry, action) {
  if (typeof supabaseClient === 'undefined') return;

  try {
    const { error } = await supabaseClient
      .from('waitlist_history')
      .insert({
        name: entry.name,
        pax: entry.pax,
        // when they were first added to the waitlist
        created_at: entry.time ? new Date(entry.time).toISOString() : null,
        action,                               // 'added' | 'seated' | 'removed'
        action_at: new Date().toISOString()  // when this specific action happened
      });

    if (error) {
      console.error('Failed to log waitlist event:', error.message);
    }
  } catch (err) {
    console.error('Unexpected error logging waitlist event:', err);
  }
}

document.getElementById('add-wait-btn')?.addEventListener('click', () => {
  const name = document.getElementById('wait-name')?.value.trim();
  const paxVal = document.getElementById('wait-pax')?.value;
  const pax = parseInt(paxVal, 10);

  if (!name || !paxVal || Number.isNaN(pax)) {
    alert('è«‹è¼¸å…¥å§“ååŠäººæ•¸');
    return;
  }

  const entry = {
    name,
    pax,
    time: Date.now()
  };

  waitlist.push(entry);

  saveWaitlist();
  renderWaitlist();

  // ğŸ”¹ log that this person was added to the waitlist
  logWaitlistEvent(entry, 'added');

  document.getElementById('wait-name').value = '';
  document.getElementById('wait-pax').value = '';
});

document.getElementById('waitlist-tbody')?.addEventListener('click', (e) => {
  const seatBtn = e.target.closest('[data-seat]');
  const removeBtn = e.target.closest('[data-remove]');

  if (seatBtn) {
    const idx = Number(seatBtn.dataset.seat);
    if (!Number.isNaN(idx)) {
      const [entry] = waitlist.splice(idx, 1);  // remove and keep the entry
      saveWaitlist();
      renderWaitlist();

      // ğŸ”¹ log that this person was seated
      if (entry) {
        logWaitlistEvent(entry, 'seated');
      }
    }
    return;
  }

  if (removeBtn) {
    const idx = Number(removeBtn.dataset.remove);
    if (!Number.isNaN(idx)) {
      const [entry] = waitlist.splice(idx, 1);  // remove and keep the entry
      saveWaitlist();
      renderWaitlist();

      // ğŸ”¹ log that this person was removed (no-show / cancelled)
      if (entry) {
        logWaitlistEvent(entry, 'removed');
      }
    }
  }
});

// Initial render
// We wrap startup in an async IIFE so we can await data (waitlist + today's
// orders from Supabase) before drawing the UI on ANY device.
(async function init() {
  // 1) Load waitlist from Supabase so the Waitlist tab is correct.
  await loadWaitlist();
  // 2) load TODAY'S orders from Supabase
  await loadTodayOrdersFromSupabase();

  // 3) THEN render UI
  renderMenu();
  updateOrder();
  renderKitchenView();
  renderBarView();
  renderAllOrdersView();
  renderCustomerView();
  renderWaitlist();
  applyTabAccessMode();

  // RESTORE THE LAST ACTIVE TAB HERE
  const savedTab = localStorage.getItem('lionrock_pos_active_tab') || 'pos';
  switchToView(savedTab);

  // ğŸ” POLLING: refresh boards every 5 seconds
  setInterval(async () => {
    await loadTodayOrdersFromSupabase();
    renderKitchenView();
    renderBarView();
    renderAllOrdersView();
    renderCustomerView();
    if (adminUnlocked) renderAdminView();
  }, 5000); // 5000ms = 5 seconds
})();

// ===== Auto-update wait time every minute (Waitlist tab) =====
setInterval(() => {
  const wlView = document.getElementById('waitlist-view');
  if (wlView && wlView.style.display !== 'none') {
    renderWaitlist();
  }
}, 60000);
</script>
</body>
</html>